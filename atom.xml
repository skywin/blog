<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[邹成卓的个人网站]]></title>
  <subtitle><![CDATA[Chengzhuo Zou's personal website]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.zoucz.com/"/>
  <updated>2016-12-22T10:50:46.505Z</updated>
  <id>http://www.zoucz.com/</id>
  
  <author>
    <name><![CDATA[邹成卓]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[nodejs进程管理工具pm2]]></title>
    <link href="http://www.zoucz.com/blog/2016/12/22/nodejs-pm2/"/>
    <id>http://www.zoucz.com/blog/2016/12/22/nodejs-pm2/</id>
    <published>2016-12-22T10:50:46.000Z</published>
    <updated>2016-12-22T10:50:46.505Z</updated>
    <content type="html"><![CDATA[<h1 id="nodejs存在的问题问题"><a href="#nodejs存在的问题问题" class="headerlink" title="nodejs存在的问题问题"></a>nodejs存在的问题问题</h1><p>nodejs作为一种单线程、单进程运行的程序，如果只是简单的使用的话，存在着如下一些问题：</p>
<ul>
<li>无法充分利用多核cpu机器的性能，</li>
<li>服务不稳定，一个未处理的异常都会导致整个程序退出</li>
<li>没有成熟的日志管理方案、</li>
<li>没有服务/进程监控机制</li>
</ul>
<p>所幸无论是nodejs本身还是强大的nodejs社区，已经有了很多比较成熟的方案来解决这些问题。</p>
<h1 id="cluster模块"><a href="#cluster模块" class="headerlink" title="cluster模块"></a>cluster模块</h1><p>从某个版本开始，nodejs提供了cluster模块来fork出多个工作线程：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>);</div><div class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">const</span> numCPUs = <span class="built_in">require</span>(<span class="string">'os'</span>).cpus().length;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (cluster.isMaster) &#123;</div><div class="line">  <span class="comment">// Fork workers.</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; numCPUs; i++) &#123;</div><div class="line">    cluster.fork();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  cluster.on(<span class="string">'exit'</span>, (worker, code, signal) =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`worker <span class="subst">$&#123;worker.process.pid&#125;</span> died`</span>);</div><div class="line">  &#125;);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="comment">// Workers can share any TCP connection</span></div><div class="line">  <span class="comment">// In this case it is an HTTP server</span></div><div class="line">  http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</div><div class="line">    res.writeHead(<span class="number">200</span>);</div><div class="line">    res.end(<span class="string">'hello world\n'</span>);</div><div class="line">  &#125;).listen(<span class="number">8000</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由主进程fork出很多的工作进程，运行我们的业务代码，主线程会持有IO句柄，将任务根据round-robin算法分发给work进程去处理。</p>
<h1 id="pm2模块"><a href="#pm2模块" class="headerlink" title="pm2模块"></a>pm2模块</h1><p>pm2是一个开源的nodejs进程管理模块，nodejs本身的cluster提供了进程管理的基础功能，pm2则对其进行了强大的封装，并提供了方便命令行程序，使用起来非常方便。其github地址：<a href="https://github.com/Unitech/pm2" title="https://github.com/Unitech/pm2" target="_blank" rel="external">https://github.com/Unitech/pm2</a></p>
<p>安装pm2： <code>npm install pm2 -g</code><br>下面简单记录一下我平时比较常用的pm2命令</p>
<h2 id="启动多个工作进程"><a href="#启动多个工作进程" class="headerlink" title="启动多个工作进程"></a>启动多个工作进程</h2><p><code>pm2 start server.js -i 5</code><br>此命令可以启动5个工作进程来运行我们的业务代码，且让nodejs程序在后台运行，提供异常退出拉起、日志、进程监控等功能。</p>
<h2 id="扩容进程"><a href="#扩容进程" class="headerlink" title="扩容进程"></a>扩容进程</h2><p><code>pm2 scale [app-name] 10</code><br>将一个服务的进程扩容到10个</p>
<h2 id="查看后台运行的服务、进程列表"><a href="#查看后台运行的服务、进程列表" class="headerlink" title="查看后台运行的服务、进程列表"></a>查看后台运行的服务、进程列表</h2><p><code>pm2 list</code><br>执行此命令可查看当前正在后台运行的服务列表及其进程列表：<br><img src="http://zoucz.com/blogimgs/2016-12-22/1482403299552.png" alt=""></p>
<h2 id="停止服务"><a href="#停止服务" class="headerlink" title="停止服务"></a>停止服务</h2><p><code>pm2 stop [app-name]</code><br>停止名字为 app-name 的服务<br><code>pm2 stop all</code><br>停止所有服务</p>
<h2 id="删除服务"><a href="#删除服务" class="headerlink" title="删除服务"></a>删除服务</h2><p><code>pm2 delete [app-name]</code><br>从列表中删除并停止名为app-name的服务<br><code>pm2 delete all</code><br>从列表中删除并停止所有服务的所有进程</p>
<h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><p><code>pm2 logs [app-name]</code><br>查看名为app-name的服务的log<br><code>pm2 logs all</code><br>查看所有服务的log</p>
<h2 id="查看进程监控"><a href="#查看进程监控" class="headerlink" title="查看进程监控"></a>查看进程监控</h2><p><code>pm2 monit [app-name]</code><br>查看服务各进程的运行情况：<br><img src="http://zoucz.com/blogimgs/2016-12-22/1482403558500.png" alt="">    </p>
<h2 id="查看服务详情"><a href="#查看服务详情" class="headerlink" title="查看服务详情"></a>查看服务详情</h2><p><code>pm2 show [app-name]</code><br>此命令会显示该服务所有进程的详细信息：<br><img src="http://zoucz.com/blogimgs/2016-12-22/1482403654426.png" alt=""></p>
<h2 id="代码热替换"><a href="#代码热替换" class="headerlink" title="代码热替换"></a>代码热替换</h2><p><code>pm2 start app.js --watch</code><br>此功能在项目开发阶段使用比较方便,其功能是在代码发生变化的时候立即自动重启服务使新代码生效。<br>可以在package.json中配置watch选项：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"watch"</span>: [<span class="string">"server"</span>, <span class="string">"client"</span>],</div><div class="line">  <span class="attr">"ignore_watch"</span> : [<span class="string">"node_modules"</span>, <span class="string">"client/img"</span>],</div><div class="line">  <span class="attr">"watch_options"</span>: &#123;</div><div class="line">    <span class="attr">"followSymlinks"</span>: <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>详见：<a href="http://pm2.keymetrics.io/docs/usage/watch-and-restart/" title="http://pm2.keymetrics.io/docs/usage/watch-and-restart/" target="_blank" rel="external">http://pm2.keymetrics.io/docs/usage/watch-and-restart/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="nodejs存在的问题问题"><a href="#nodejs存在的问题问题" class="headerlink" title="nodejs存在的问题问题"></a>nodejs存在的问题问题</h1><p>nodejs作为一种单线程、单进程运行的程序，如果只]]>
    </summary>
    
      <category term="nodejs" scheme="http://www.zoucz.com/blog/tags/nodejs/"/>
    
      <category term="nodejs" scheme="http://www.zoucz.com/blog/categories/nodejs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[测试新编辑器]]></title>
    <link href="http://www.zoucz.com/blog/2016/12/22/test-new-editor/"/>
    <id>http://www.zoucz.com/blog/2016/12/22/test-new-editor/</id>
    <published>2016-12-22T10:11:08.000Z</published>
    <updated>2016-12-22T10:11:08.641Z</updated>
    <content type="html"><![CDATA[<ul>
<li>test</li>
<li>test2</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<ul>
<li>test</li>
<li>test2</li>
</ul>
]]>
    </summary>
    
      <category term="nodejs" scheme="http://www.zoucz.com/blog/tags/nodejs/"/>
    
      <category term="浏览器" scheme="http://www.zoucz.com/blog/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[测试]]></title>
    <link href="http://www.zoucz.com/blog/2016/12/22/test-new%20editor/"/>
    <id>http://www.zoucz.com/blog/2016/12/22/test-new editor/</id>
    <published>2016-12-22T10:04:11.000Z</published>
    <updated>2016-12-22T10:04:11.717Z</updated>
    <content type="html"><![CDATA[<ul>
<li>test</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<ul>
<li>test</li>
</ul>
]]>
    </summary>
    
      <category term="nodejs" scheme="http://www.zoucz.com/blog/tags/nodejs/"/>
    
      <category term="浏览器" scheme="http://www.zoucz.com/blog/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[vue与chrome浏览器插件开发]]></title>
    <link href="http://www.zoucz.com/blog/2016/08/31/vue-chrome-extensions/"/>
    <id>http://www.zoucz.com/blog/2016/08/31/vue-chrome-extensions/</id>
    <published>2016-08-31T03:44:14.000Z</published>
    <updated>2016-12-21T16:42:00.000Z</updated>
    <content type="html"><![CDATA[<p>项目中需要从百度图片和谷歌图片批量抓取一系列关键词的图片，而且需要是大图资源，不能是缩略图。<br>在后端通过http请求直接拉取内容抓取，遇到下面两个问题：</p>
<ul>
<li>有的大图地址是在前端通过脚本生成的，拉取页面内容之后无法直接得到大图地址</li>
<li>翻页请求并不是简单的pageindex++，拿到下一页内容。抓取第一页后边的内容也需要分析翻页请求链接组装，以及返回的数据如何解析。    </li>
</ul>
<p>这两个问题导致通过后端爬取大图列表十分困难。于是我想起了以前玩过的杂技——浏览器插件。通过javascript控制浏览器打开网页，搜索关键词，页面渲染完毕之后拿到大图地址，第一页拿完之后让页面滚动到底部，继续加载图片，and so on!直到拿到足够数量的图片。<br>做完这个小工具，想着总结一下经验，加深点印象，免得以后某一天有需要再来做的时候一脸懵逼，于是抽时间慢慢写下这边文章记录一下我对浏览器插件的认识。</p>
<h1 id="什么是chrome浏览器插件"><a href="#什么是chrome浏览器插件" class="headerlink" title="什么是chrome浏览器插件"></a>什么是chrome浏览器插件</h1><p><img src="http://zoucz.com/blogimgs/2016-08-30/1472541011802.png" alt=""><br>地址栏右侧那些icon就是一个个浏览器插件。点击插件图标可以弹出插件窗口。<br>我所理解的chrome浏览器插件功能有三大块：</p>
<ul>
<li>弹出一个窗口，让用户执行操作，或者显示信息</li>
<li>向网页中注入脚本文件，执行某些功能</li>
<li>调用chrome提供的native api，执行浏览器tab页开关、窗口开关、文件下载等操作</li>
</ul>
<p>如上图腾讯电脑管家的插件，就是用来提供广告过滤功能的。它的工作原理应该就是给需要过滤的网址插入一段脚本，来把页面上的广告标签干掉。</p>
<h1 id="chrome插件开发"><a href="#chrome插件开发" class="headerlink" title="chrome插件开发"></a>chrome插件开发</h1><p>文档地址：<a href="https://developer.chrome.com/extensions/overview" title="https://developer.chrome.com/extensions/overview" target="_blank" rel="external">https://developer.chrome.com/extensions/overview</a></p>
<h2 id="代码模块"><a href="#代码模块" class="headerlink" title="代码模块"></a>代码模块</h2><p>chrome插件完全由javascript、html、css开发，和上面的插件功能相对应，代码也可以分为三大模块：</p>
<ul>
<li>popup 弹出窗口代码集合。弹窗UI通过html+css开发，弹窗中也可以引用js脚本来控制交互操作。每个弹窗都相当于一个独立的tab页，运行在其中的js脚本拥有一个独立的上下文。</li>
<li>inject.js。注入网页文件的脚本。需要注意的是，注入的脚本上下文也是独立的，它可以操作目标网页DOM，但是并不在目标网页脚本的上下文中。</li>
<li>background.js。插件后台脚本，拥有独立的上下文，且此上下文是唯一的，无论浏览器打开多少个tab页，background.js的上下文都不会变化，除非关闭浏览器。</li>
</ul>
<p>这三块代码之间的关系我画了个图方便理解：<br><img src="http://zoucz.com/blogimgs/2016-08-30/1472543851862.png" alt=""></p>
<p>图中，黑色的部分代表chrome原生部分，其他的每一个方块都拥有一个独立的javascript上下文。</p>
<h2 id="manifest-json"><a href="#manifest-json" class="headerlink" title="manifest.json"></a>manifest.json</h2><p>chrome插件有一个比较重要的配置文件，manifest.json，用来指定各个模块的代码文件名、插件权限、插件图标、inject脚本插入时机等<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"name"</span>: <span class="string">"imagefetcher"</span>,</div><div class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.1"</span>,</div><div class="line">  <span class="attr">"manifest_version"</span>: <span class="number">2</span>,</div><div class="line">  <span class="attr">"description"</span>: <span class="string">"抓取图片网站大图文件"</span>,</div><div class="line">  <span class="attr">"background"</span>: &#123; <span class="attr">"scripts"</span>: [<span class="string">"dist/background.js"</span>] &#125;,</div><div class="line">  <span class="attr">"icons"</span>: &#123; <span class="attr">"16"</span>: <span class="string">"icon.jpg"</span>,</div><div class="line">    <span class="attr">"48"</span>: <span class="string">"icon.jpg"</span>,</div><div class="line">    <span class="attr">"128"</span>: <span class="string">"icon.jpg"</span> &#125;,</div><div class="line">  <span class="attr">"permissions"</span>: [</div><div class="line">    <span class="string">"tabs"</span>,<span class="string">"downloads"</span>,</div><div class="line">    <span class="string">"http://*.baidu.com/"</span>,</div><div class="line">    <span class="string">"http://*.google.com.hk/"</span></div><div class="line">  ],</div><div class="line">  <span class="attr">"browser_action"</span>: &#123;</div><div class="line">    <span class="attr">"default_icon"</span>: <span class="string">"icon.jpg"</span> ,</div><div class="line">    <span class="attr">"default_title"</span>: <span class="string">"抓取图片"</span>,</div><div class="line">    <span class="attr">"default_popup"</span>: <span class="string">"index.html"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">"content_scripts"</span>:[&#123;</div><div class="line">    <span class="attr">"run_at"</span>:<span class="string">"document_end"</span>,</div><div class="line">    <span class="attr">"matches"</span>:[<span class="string">"&lt;all_urls&gt;"</span>],</div><div class="line">    <span class="attr">"js"</span>:[<span class="string">"lib/jquery-2.0.0.min.js"</span>, <span class="string">"dist/inject.js"</span>]</div><div class="line">  &#125;]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>background指定background代码文件路径；content_scripts指定inject的脚本列表，以及注入的条件、注入时机；browser_action中的default_popup指定popup弹出的html文件路径；permissions指定能访问的网页或chrome提供的一些功能的权限；icons指定插件图标。</p>
<h2 id="模块间通信"><a href="#模块间通信" class="headerlink" title="模块间通信"></a>模块间通信</h2><p>按照上面的结构，很容易可以联想到各个模块的分工：<br><strong>popup模块</strong> 的代码负责显示弹窗，让用户输入关键词，下发开始抓取指令；显示抓取进度；下发下载指令。<br><strong>inject.js</strong>负责分析网页的DOM，拿到大图资源链接，并翻页，直到获取足够数量的图片。<br><strong>background.js</strong>负责汇总各个网页抓取的结果，并将结果显示到弹窗中。<br>由于这些脚本拥有各自的执行上下文，并不能通过直接调用函数的方式来通信，所以我们需要通过chrome提供的方式来进行模块间的通信。</p>
<h3 id="与background的通信"><a href="#与background的通信" class="headerlink" title="与background的通信"></a>与background的通信</h3><p>在popup中或者inject中发出消息给background接收。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chrome.runtime.sendMessage(&#123;<span class="attr">action</span>:ACTION.START_FETCH,<span class="attr">data</span>:xxxx&#125;);</div></pre></td></tr></table></figure></p>
<p>sendMessage函数还可以接受一个回调函数，处理收到消息之后处理的返回结果。    <code>rome.runtime.sendMessage(string extensionId, any message, object options, function responseCallback)</code></p>
<p>在background.js中监听消息：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">chrome.runtime.onMessage.addListener(<span class="function"><span class="keyword">function</span>(<span class="params">request, sender, sendRequest</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> data=request.data;</div><div class="line">    <span class="keyword">var</span> fetch;</div><div class="line">    <span class="keyword">if</span>(data.tab_id)&#123;</div><div class="line">        fetch=<span class="built_in">window</span>.FETCH_ITEMS.getByTabId(data.tab_id);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//开始抓取消息，读取抓取队列的第一个，开始抓取，抓取完成之后继续读</span></div><div class="line">    <span class="keyword">if</span>(request.action==ACTION.START_FETCH)&#123;</div><div class="line">        __fetch_list.push(data);</div><div class="line">        readFetchList();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(request.action==ACTION.FETCH_PROGTRESS)&#123;</div><div class="line">        fetch.urls=data.urls;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//抓取完成，修改fetch_item状态，若存在弹窗，通知弹窗刷新视图</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(request.action==ACTION.FETCH_SUCCESS)&#123;</div><div class="line">        fetch.status=DOWNLOAD_STATUS.SUCCESS;</div><div class="line">        fetch.urls=data.urls;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="与inject的通信"><a href="#与inject的通信" class="headerlink" title="与inject的通信"></a>与inject的通信</h3><p>要指挥inject的脚本执行一些操作，必须给inject发消息，而inject是注入网页中的，所以发消息第一步必须先获取tab页的tabid，然后将消息发给特定的tab页。<br>在background中发出消息：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">chrome.tabs.getSelected(<span class="function"><span class="keyword">function</span>(<span class="params">tab</span>)</span>&#123;</div><div class="line">    chrome.tabs.sendMessage(tab.id, data, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(response);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>inject中接收消息：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">chrome.runtime.onMessage.addListener(<span class="function"><span class="keyword">function</span>(<span class="params">request, sender, sendResponse</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> data=request.data;</div><div class="line">    <span class="comment">//开始抓取</span></div><div class="line">    <span class="keyword">if</span>(request.action==ACTION.START_FETCH)&#123;</div><div class="line">        <span class="keyword">var</span> site=SITES.getSite(data.site);</div><div class="line">        <span class="keyword">if</span>(!site)&#123;</div><div class="line">            sendResponse(&#123;<span class="attr">err</span>:<span class="number">1</span>,<span class="attr">message</span>:<span class="string">"未实现此网页抓取"</span>&#125;);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        sendResponse(&#123;<span class="attr">err</span>:<span class="number">0</span>&#125;);</div><div class="line">        fetcher=<span class="built_in">require</span>(<span class="string">'./fetchors/'</span>+data.site);</div><div class="line">        fetcher(data).then(<span class="function"><span class="keyword">function</span>(<span class="params">urls</span>)</span>&#123;</div><div class="line">            data.urls=urls;</div><div class="line">            chrome.runtime.sendMessage(&#123;<span class="attr">action</span>:ACTION.FETCH_SUCCESS, <span class="attr">data</span>:data&#125;); <span class="comment">//发送给background</span></div><div class="line">        &#125;).done()</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>不能调试还写什么代码！ chrome插件的三大模块也是可以调试的，只不过都藏在各种犄角旮旯里边，下面扒一扒怎么分别给他们打断点。</p>
<h3 id="background"><a href="#background" class="headerlink" title="background"></a>background</h3><p>打开<code>chrome://extensions/</code><br><img src="http://zoucz.com/blogimgs/2016-08-31/1472614775230.png" alt=""><br>点“检查视图”后边的链接，就可以打开控制台了，在source里边打上断点，调试走起</p>
<h3 id="popup"><a href="#popup" class="headerlink" title="popup"></a>popup</h3><p><img src="http://zoucz.com/blogimgs/2016-08-31/1472614858204.png" alt=""><br>在插件图标上右键——审查弹出内容，打开控制台，在source里边打上断点，调试走起</p>
<h3 id="inject"><a href="#inject" class="headerlink" title="inject"></a>inject</h3><p><img src="http://zoucz.com/blogimgs/2016-08-31/1472614946123.png" alt=""><br>按F12打开被注入的页面的控制台，点Sources，点右侧中间的Content Scripts，就可以看到这个页面被那些插件注入了脚本了，根据名称找到自己的脚本，打上断点，调试走起</p>
<h1 id="使用vue开发chrome插件"><a href="#使用vue开发chrome插件" class="headerlink" title="使用vue开发chrome插件"></a>使用vue开发chrome插件</h1><h2 id="vue带来的好处"><a href="#vue带来的好处" class="headerlink" title="vue带来的好处"></a>vue带来的好处</h2><h3 id="干掉DOM操作"><a href="#干掉DOM操作" class="headerlink" title="干掉DOM操作"></a>干掉DOM操作</h3><p>我开发的chrome插件是一个用来完成图片下载任务的插件。抓取过程中，需要显示抓取进度，并可以进行删除下载，其中涉及很多DOM操作。使用vue可以减少大量的dom操作代码，这个不细讲，参见<a href="http://vuejs.org/guide/" title="http://vuejs.org/guide/" target="_blank" rel="external">http://vuejs.org/guide/</a><br><img src="https://raw.githubusercontent.com/zouchengzhuo/BigImageFetcher/master/guide/fetch.gif" alt=""></p>
<h3 id="干掉复杂的通信"><a href="#干掉复杂的通信" class="headerlink" title="干掉复杂的通信"></a>干掉复杂的通信</h3><p>这个是我觉得用vue开发chrome插件最有价值的部分了，前边介绍了插件几大模块之间的通信，需要调用chrome提供的接口进行频繁的发送消息和监听处理。<br>通过<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chrome.extension.getBackgroundPage()</div></pre></td></tr></table></figure></p>
<p>可以拿到插件background脚本的window对象，注意这个background的执行上下文是只有一个的，所以在插件运行期间我们可以用它来存储各个tab页抓取回来的数据。<br>在popup的脚本中：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> FETCH_ITEMS=chrome.extension.getBackgroundPage().FETCH_ITEMS;</div><div class="line"><span class="keyword">var</span> vm=<span class="keyword">new</span> Vue(&#123;</div><div class="line">    <span class="attr">el</span>: <span class="string">'#wrapper'</span>,</div><div class="line">    <span class="attr">data</span>: &#123;</div><div class="line">        <span class="attr">FETCH_ITEMS</span>: FETCH_ITEMS</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">methods</span>:&#123;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这样，将从各个tab页抓取回来的数据push到background.js暴露出来的一个对象中，popup弹出的网页中就可以实时显示抓取进度了，不需要在popup和background之间编写大量的通信代码。<br>至于各个tab页和background之间的通信，可以使用上面chrome提供的通信方式，也可以自己拿到background的window对象暴露出的变量，再进行操作。这里并没有复杂的视图更新和用户操作，所以怎么通信都无所谓了~</p>
<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><p><img src="http://zoucz.com/blogimgs/2016-08-31/1472613641660.png" alt=""><br>按照上面理解的结构，每个模块的代码集中到一起。<br>另外，插件中也允许根据路径直接访问插件中的资源，其路径是“chrome-extension://[extensionId]/[resourceName]” 。<br>select目录中存放的是一个用来筛选图片的页面代码，在popup页面中直接跳转到<code>/select.html</code>即可打开此页面。    </p>
<p>插件开发完成打包之后，把这些资源放到一个文件夹中<br><img src="http://zoucz.com/blogimgs/2016-08-31/1472613890160.png" alt=""><br>然后打开<code>chrome://extensions/</code><br><img src="http://zoucz.com/blogimgs/2016-08-31/1472613951515.png" alt=""><br>选择上面的目录即可看到地址栏右侧出现插件的图标。</p>
<h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><p>初次在chrome插件开发中使用vue的时候，遇到了这样一个问题：<br><img src="http://zoucz.com/blogimgs/2016-08-31/1472614093409.png" alt=""><br>模型更新了，视图始终不更新，然后打开调试界面后运行<code>vm.$mount(&quot;#wrapper&quot;);</code>，视图却更新了。<br>百思不得其解，google之，发现chrome插件中有些javascript代码写法和正常环境中有所不同，幸好vue居然贴心的为这种情况准备了一个特殊的包，不然就前功尽弃了 :(<br>这里总结了一个经验，用前端框架开发的过程中最好不要使用.min的包，打包好的代码里边会去掉一些警告的逻辑…  把.min包替换成非压缩包之后，看到了这个错误：<br><img src="http://zoucz.com/blogimgs/2016-08-31/1472614357135.png" alt=""><br>根据提示，在vue的项目里边找到了一个叫CSP的分支<br><a href="https://github.com/vuejs/vue/tree/csp/dist" title="https://github.com/vuejs/vue/tree/csp/dist " target="_blank" rel="external">https://github.com/vuejs/vue/tree/csp/dist </a><br><img src="http://zoucz.com/blogimgs/2016-08-31/1472614418582.png" alt=""><br>看文档说明，果然就是为插件开发定制的啊！ 没想到那么偏门的场合他们也有关注到！</p>
<h1 id="成品"><a href="#成品" class="headerlink" title="成品"></a>成品</h1><p><a href="https://github.com/zouchengzhuo/BigImageFetcher" title="https://github.com/zouchengzhuo/BigImageFetcher" target="_blank" rel="external">https://github.com/zouchengzhuo/BigImageFetcher</a><br>抓取的资源路径都是源站的，所以并不用担心百度和google会封IP，可以放心抓取~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>项目中需要从百度图片和谷歌图片批量抓取一系列关键词的图片，而且需要是大图资源，不能是缩略图。<br>在后端通过http请求直接拉取内容抓取，遇到下面两个问题：</p>
<ul>
<li>有的大图地址是在前端通过脚本生成的，拉取页面内容之后无法直接得到大图地址</li>
<l]]>
    </summary>
    
      <category term="前端开发" scheme="http://www.zoucz.com/blog/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="浏览器插件" scheme="http://www.zoucz.com/blog/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/"/>
    
      <category term="前端杂烩" scheme="http://www.zoucz.com/blog/categories/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[javascript单元测试框架mochajs详解]]></title>
    <link href="http://www.zoucz.com/blog/2016/08/02/nodejs-unittest-mochajs/"/>
    <id>http://www.zoucz.com/blog/2016/08/02/nodejs-unittest-mochajs/</id>
    <published>2016-08-02T07:45:29.000Z</published>
    <updated>2016-12-21T16:42:00.000Z</updated>
    <content type="html"><![CDATA[<h1 id="关于单元测试的想法"><a href="#关于单元测试的想法" class="headerlink" title="关于单元测试的想法"></a>关于单元测试的想法</h1><p>对于一些比较重要的项目，每次更新代码之后总是要自己测好久，担心一旦上线出了问题影响的服务太多，此时就希望能有一个比较规范的测试流程。在github上看到牛逼的javascript开源项目，也都是有测试代码的，看来业界大牛们都比较注重单元测试这块。<br>就我自己的理解而言：</p>
<ul>
<li>涉及到大量业务逻辑的代码，可能我没有精力去给每个函数都写上单元测试的代码，功能细节的测试应该交由测试的同事去完成，但是对会直接影响项目正常运行的重要的数据接口，还是可以看情况写上几个单元测试用例的，每一次修改之后跑一跑用例测试一下。    </li>
<li>重要的框架底层模块，任何地方出一个小问题，都可能影响到很多服务。对于这种模块，最好是每个函数、每种接口都写上单元测试代码，不然一出问题就是一个大坑啊。</li>
<li>开放出去的公共模块，可以针对主要的函数和接口写上单元测试代码，这样可以确保模块代码比较健壮，看起来也专业一些：）。    </li>
</ul>
<p>基于以上几个想法，我决定学习一款Javascript单元测试框架，并试试去使用它写一些单元测试的代码。<br>看了很多技术站点和博客的文章，参考了一部分开源项目的测试代码，大致观望下风向，决定学习一下mocha.js这款单元测试框架。<br>别人的文章都是别人自己学习、咀嚼理解出来的内容，想学的透彻一点，还是自己学习并翻译一遍原版官方的文档比较好。</p>
<h1 id="mocha单元测试框架简介"><a href="#mocha单元测试框架简介" class="headerlink" title="mocha单元测试框架简介"></a>mocha单元测试框架简介</h1><p>mocha是一款功能丰富的javascript单元测试框架，它既可以运行在nodejs环境中，也可以运行在浏览器环境中。<br>javascript是一门单线程语言，最显著的特点就是有很多异步执行。同步代码的测试比较简单，直接判断函数的返回值是否符合预期就行了，而异步的函数，就需要测试框架支持回调、promise或其他的方式来判断测试结果的正确性了。mocha可以良好的支持javascript异步的单元测试。<br>mocha会串行地执行我们编写的测试用例，可以在将未捕获异常指向对应用例的同时，保证输出灵活准确的测试结果报告。</p>
<h1 id="安装mocha"><a href="#安装mocha" class="headerlink" title="安装mocha"></a>安装mocha</h1><p><code>npm install mocha -g</code> </p>
<h1 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h1><p>全局安装mocha后，在项目根目录创建test目录<br>编写<code>test01.js</code> ，<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> assert = <span class="built_in">require</span>(<span class="string">'chai'</span>).assert;</div><div class="line">describe(<span class="string">'Array'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  describe(<span class="string">'#indexOf()'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    it(<span class="string">'should return -1 when the value is not present'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      assert.equal(<span class="number">-1</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].indexOf(<span class="number">5</span>));</div><div class="line">      assert.equal(<span class="number">-1</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].indexOf(<span class="number">0</span>));</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><code>npm install chai --save</code> 安装一下官方文档中使用的chai断言模块（一个用来判断结果是否正确的模块）<br>打开控制台，在test目录同级运行<code>mocha</code>，得到如下结果：<br>     Array</p>
<pre><code>  #indexOf()
    √ should return -1 when the value is not present
1 passing (11ms)
</code></pre><p>可以看到：<br>describe函数的第一个参数会被输出在控制台中，作为一个用例集的描述，而且这个描述是可以根据自己的需求来嵌套输出的，下面称之为：<strong>用例集定义函数</strong>。<br>it函数第一个参数用来输出一个用例的描述，前边打个对勾代表测试通过，第二个参数是一个函数，用来编写用例内容，用断言模块来判断结果的正确性，下面称之为<strong>用例函数</strong>。</p>
<h1 id="mocha支持的断言模块"><a href="#mocha支持的断言模块" class="headerlink" title="mocha支持的断言模块"></a>mocha支持的断言模块</h1><p>mocha支持任何可以抛出一个错误的断言模块。例如：should.js、better-assert、expect.js、unexpected、chai等。这些断言库各有各的特点，大家可以了解一下它们的特点，根据使用场景来选择断言库。</p>
<h1 id="同步代码测试"><a href="#同步代码测试" class="headerlink" title="同步代码测试"></a>同步代码测试</h1><p>在测试同步代码的时候，用例函数执行完毕后，mocha就直接开始执行下一个用例函数了。 下面是一个同步测试代码的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">describe(<span class="string">'Array'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  describe(<span class="string">'#indexOf()'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    it(<span class="string">'should return -1 when the value is not present'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].indexOf(<span class="number">5</span>).should.equal(<span class="number">-1</span>);</div><div class="line">      [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].indexOf(<span class="number">0</span>).should.equal(<span class="number">-1</span>);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h1 id="异步代码测试"><a href="#异步代码测试" class="headerlink" title="异步代码测试"></a>异步代码测试</h1><p>官方文档自称，用mocha来测试异步的代码不要再简单！真的很自信啊~~<br>只需要在用例函数里边加一个done回调，异步代码执行完毕后调用一下done，就可以通知mocha，我执行完啦，去执行下一个用例函数吧！<br>就像下面这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">describe(<span class="string">'User'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  describe(<span class="string">'#save()'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    it(<span class="string">'should save without error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">done</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> user = <span class="keyword">new</span> User(<span class="string">'Luna'</span>);</div><div class="line">      user.save(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</div><div class="line">        done();</div><div class="line">      &#125;);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>对于上面的情况，判断用例执行成功与否是在异步代码的回调里边完成的，这种情况适用于正确性判断比较复杂的情况。如果异步代码中逻辑错误时，会在回调中抛出一个错误，那么测试代码还可以再简单一点：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">describe(<span class="string">'User'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  describe(<span class="string">'#save()'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    it(<span class="string">'should save without error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">done</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> user = <span class="keyword">new</span> User(<span class="string">'Luna'</span>);</div><div class="line">      user.save(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</div><div class="line">        done();</div><div class="line">      &#125;);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h1 id="promise代码测试"><a href="#promise代码测试" class="headerlink" title="promise代码测试"></a>promise代码测试</h1><p>如果异步模块并不是使用callback，而是使用promise来返回结果的时候，可以让用例函数返回一个promise对象来进行正确性判断，像下面这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">beforeEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> db.clear()</div><div class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> db.save([tobi, loki, jane]);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">describe(<span class="string">'#find()'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  it(<span class="string">'respond with matching records'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> db.find(&#123; <span class="attr">type</span>: <span class="string">'User'</span> &#125;).should.eventually.have.length(<span class="number">3</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>后边还会再提到这种情况</p>
<h1 id="不建议使用箭头函数"><a href="#不建议使用箭头函数" class="headerlink" title="不建议使用箭头函数"></a>不建议使用箭头函数</h1><p>不建议在mocha测试框架中使用箭头函数。箭头函数语法中对this的绑定让会用例函数没办法访问Mocha框架上下文中定义的一些函数，例如<code>this.timeout(1000)</code>在箭头函数中就无法得到正确的结果。<br>我对这里的理解是：mocha会把用例函数注册到自身的某个属性中，通过属性调用的使用，正常函数可以访问到mocha的其他属性，但是箭头函数不行，就像下面的代码一样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTest</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.a=<span class="number">555</span>;</div><div class="line">    <span class="keyword">var</span> test=&#123;</div><div class="line">        <span class="attr">a</span>:<span class="number">1</span>,</div><div class="line">        <span class="attr">b</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">c</span>:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">    <span class="keyword">return</span> test;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> test=getTest();</div><div class="line">test.b();</div><div class="line">test.c();</div></pre></td></tr></table></figure></p>
<p>输出结果是<br>    1<br>    555</p>
<h1 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h1><p>mocha提供4种钩子函数：<code>before()</code>、<code>after()</code>、<code>beforeEach()</code>、<code>afterEach()</code>，这些钩子函数可以用来在用例集/用例函数开始执行之前/结束执行之后，进行一些环境准备或者环境清理的工作。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">describe(<span class="string">'hooks'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  before(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// runs before all tests in this block</span></div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// runs after all tests in this block</span></div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  beforeEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// runs before each test in this block</span></div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  afterEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// runs after each test in this block</span></div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="comment">// test cases</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="钩子函数的描述参数"><a href="#钩子函数的描述参数" class="headerlink" title="钩子函数的描述参数"></a>钩子函数的描述参数</h2><p>定义钩子函数的时候，可以传第一个可选参数作为钩子函数的描述，可以帮助定位用例中的错误信息。若没有穿第一个参数，使用一个非匿名函数作为钩子函数，那么函数名称就将被作为钩子函数的描述。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">beforeEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// beforeEach hook</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">beforeEach(<span class="function"><span class="keyword">function</span> <span class="title">namedFun</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// beforeEach:namedFun</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">beforeEach(<span class="string">'some description'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// beforeEach:some description</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="异步的钩子函数"><a href="#异步的钩子函数" class="headerlink" title="异步的钩子函数"></a>异步的钩子函数</h2><p>钩子函数不仅能是同步函数，也可能是异步的函数，就像前边的异步测试用例函数一样。如果我们在开始之前，需要做一些异步的操作，例如在数据库里边准备一些模拟数据，就需要用到这种场景了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">describe(<span class="string">'Connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> db = <span class="keyword">new</span> Connection,</div><div class="line">    tobi = <span class="keyword">new</span> User(<span class="string">'tobi'</span>),</div><div class="line">    loki = <span class="keyword">new</span> User(<span class="string">'loki'</span>),</div><div class="line">    jane = <span class="keyword">new</span> User(<span class="string">'jane'</span>);</div><div class="line"></div><div class="line">  beforeEach(<span class="function"><span class="keyword">function</span>(<span class="params">done</span>) </span>&#123;</div><div class="line">    db.clear(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> done(err);</div><div class="line">      db.save([tobi, loki, jane], done);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  describe(<span class="string">'#find()'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    it(<span class="string">'respond with matching records'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">done</span>) </span>&#123;</div><div class="line">      db.find(&#123;<span class="attr">type</span>: <span class="string">'User'</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (err) <span class="keyword">return</span> done(err);</div><div class="line">        res.should.have.length(<span class="number">3</span>);</div><div class="line">        done();</div><div class="line">      &#125;);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="全局钩子"><a href="#全局钩子" class="headerlink" title="全局钩子"></a>全局钩子</h2><p>前边讲的钩子函数都是定义在用例集函数里边的，如果在用例集函数之外定义钩子函数，那么这个钩子函数将会对所有的mocha单元测试用例生效。若编写了多个用例集js文件，无论在哪一个用例集文件中，用例集函数之外定义钩子函数，都会对所有用例函数生效。<br>前边讲到，用例集函数是可以嵌套的，而mocha会生成一个包在最外面的describe函数，把所有的用例集包含起来，那么在其中定义的钩子函数也就对所有的用例函数生效了~<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">beforeEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'before every test in every file'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="延迟启动测试"><a href="#延迟启动测试" class="headerlink" title="延迟启动测试"></a>延迟启动测试</h2><p>如果想在mocha命令运行之后，先做一些别的工作，再启动测试，可以使用<code>mocha --delay</code>命令，此命令会在全局环境中生成一个run函数，延迟工作完成后调用run函数即可启动测试。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// do some setup</span></div><div class="line"></div><div class="line">  describe(<span class="string">'my suite'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  run();</div><div class="line">&#125;, <span class="number">5000</span>);</div></pre></td></tr></table></figure></p>
<h1 id="测试用例TODO"><a href="#测试用例TODO" class="headerlink" title="测试用例TODO"></a>测试用例TODO</h1><p>可以编写一个等待被实现的测试用例，在报告里边也会有提示<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">describe(<span class="string">'Array'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  describe(<span class="string">'#indexOf()'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// pending test below</span></div><div class="line">    it(<span class="string">'should return -1 when the value is not present'</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<pre><code>2 passing (11ms)
 1 pending
</code></pre><h1 id="仅执行一个用例集-用例"><a href="#仅执行一个用例集-用例" class="headerlink" title="仅执行一个用例集/用例"></a>仅执行一个用例集/用例</h1><p>在用例集函数或者用例函数后边添加<code>.only()</code>可以让mocha只执行此用例集或用例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">describe(<span class="string">'Array'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  describe.only(<span class="string">'#indexOf()'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>Array用例集下面的嵌套集合，只有#indexOf用例集会被执行<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">describe(<span class="string">'Array'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  describe(<span class="string">'#indexOf()'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    it.only(<span class="string">'should return -1 unless present'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    it(<span class="string">'should return the index when present'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这种写法，#indexOf用例集下面的用例，只有第一个加了only的会被执行。<br>注意：在同一用例集下有多个only标记，mocha会报错。 </p>
<h1 id="跳过哪些用例集-用例"><a href="#跳过哪些用例集-用例" class="headerlink" title="跳过哪些用例集/用例"></a>跳过哪些用例集/用例</h1><p>和加上.only相反，在用例集函数或者用例函数后边加<code>.skip()</code>，可以跳过此用例集或用例的执行。跳过的用例会被标记为<code>pending</code>的用例，在报告中也会作为pending用例体现出来。下面是一些例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">describe(<span class="string">'Array'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  describe.skip(<span class="string">'#indexOf()'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>跳过用例集<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">describe(<span class="string">'Array'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  describe(<span class="string">'#indexOf()'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    it.skip(<span class="string">'should return -1 unless present'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    it(<span class="string">'should return the index when present'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>跳过用例。<br>对于一些作废的用例，按我们以往的做法可能就是把它注释掉，mocha推荐的做法是给它们加上skip标记。    </p>
<p>除了使用添加skip标记之外，mocha还允许在用例执行的过程中跳过此用例，例如用例执行需要某些上下文环境，但是执行的时候发现这些环境并没有准备好，此时就可以调用skip函数跳过此用例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">it(<span class="string">'should only test in the correct environment'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="comment">/* check test environment */</span>) &#123;</div><div class="line">    <span class="comment">// make assertions</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">this</span>.skip();</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>上面被跳过的用例同样会在测试报告中以pending的形式体现出来。为了避免测试逻辑混乱，在调用skip函数之后，就不要再再用例函数或after钩子中执行更多的逻辑了。    </p>
<p>这里要说明一点，在一个用例函数中，不要存在一个逻辑分支啥也不做，直接让整个用例函数结束，这样是不科学的。用例函数中应该至少使用断言做一个判断，或者调用skip函数跳过用例。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">it(<span class="string">'should only test in the correct environment'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="comment">/* check test environment */</span>) &#123;</div><div class="line">    <span class="comment">// make assertions</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// do nothing</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这样的用例如果走到了do nothing逻辑，在报告中会被标记为pass。比较推荐的做法是，在before钩子函数中检查测试需要的上下文环境，不具备则跳过。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">before(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="comment">/* check test environment */</span>) &#123;</div><div class="line">    <span class="comment">// setup code</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">this</span>.skip();</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h1 id="重新执行用例"><a href="#重新执行用例" class="headerlink" title="重新执行用例"></a>重新执行用例</h1><p>你可以指定让一个失败的用例重新执行一定次数。这个特性是为做<strong>end-to-end测试</strong>(功能性测试/Selenium测试)而设计的，这些测试数据不好模拟。 <strong>mocha是不推荐用这个特性来做单元测试的。</strong>    </p>
<p>这个特性会重新运行用例函数的beforeEach和afterEach钩子函数，但是不会重新运行before和after钩子函数。</p>
<p>下面是一个重新执行的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">describe(<span class="string">'retries'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// Retry all tests in this suite up to 4 times</span></div><div class="line">  <span class="keyword">this</span>.retries(<span class="number">4</span>);</div><div class="line">  </div><div class="line">  beforeEach(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    browser.get(<span class="string">'http://www.yahoo.com'</span>);</div><div class="line">  &#125;);</div><div class="line">  </div><div class="line">  it(<span class="string">'should succeed on the 3rd try'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// Specify this test to only retry up to 2 times</span></div><div class="line">    <span class="keyword">this</span>.retries(<span class="number">2</span>);</div><div class="line">    expect($(<span class="string">'.foo'</span>).isDisplayed()).to.eventually.be.true;</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h1 id="动态生成用例"><a href="#动态生成用例" class="headerlink" title="动态生成用例"></a>动态生成用例</h1><p>mocha可以使用<code>Function.prototype.call</code>和函数表达式来定义用例集和用例，它们可以用来直接动态生成一些测试用例，而不需要使用其他额外的语法。<br>和你可能在其他框架中见到的一样，这个特性可以实现通过定义一些参数来实现测试用例的功能。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> assert = <span class="built_in">require</span>(<span class="string">'chai'</span>).assert;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>).reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, curr</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> prev + curr;</div><div class="line">  &#125;, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">describe(<span class="string">'add()'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> tests = [</div><div class="line">    &#123;<span class="attr">args</span>: [<span class="number">1</span>, <span class="number">2</span>],       <span class="attr">expected</span>: <span class="number">3</span>&#125;,</div><div class="line">    &#123;<span class="attr">args</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],    <span class="attr">expected</span>: <span class="number">6</span>&#125;,</div><div class="line">    &#123;<span class="attr">args</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="attr">expected</span>: <span class="number">10</span>&#125;</div><div class="line">  ];</div><div class="line"></div><div class="line">  tests.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">test</span>) </span>&#123;</div><div class="line">    it(<span class="string">'correctly adds '</span> + test.args.length + <span class="string">' args'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> res = add.apply(<span class="literal">null</span>, test.args);</div><div class="line">      assert.equal(res, test.expected);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>上面的测试会生成下面这样报告：<br>      add()<br>        ✓ correctly adds 2 args<br>        ✓ correctly adds 3 args<br>        ✓ correctly adds 4 args</p>
<h1 id="测试时间"><a href="#测试时间" class="headerlink" title="测试时间"></a>测试时间</h1><p>许多测试报告会展示测试时间，同样也会标记出那些用例耗时比较长：<br><img src="http://zoucz.com/blogimgs/2016-07-27/1469587478096.png" alt=""></p>
<p>可能对于某些测试用例，耗时就是会比较长，那么耗费多长时间才应该本认为执行耗时过长呢？ 可以通过<code>slow()</code>函数来标记一下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">describe(<span class="string">'something slow'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.slow(<span class="number">10000</span>);</div><div class="line"></div><div class="line">  it(<span class="string">'should take long enough for me to go make a sandwich'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h1 id="测试超时"><a href="#测试超时" class="headerlink" title="测试超时"></a>测试超时</h1><h2 id="用例集执行超时"><a href="#用例集执行超时" class="headerlink" title="用例集执行超时"></a>用例集执行超时</h2><p>在用例集下定义的timeout超时会对此用例集下定义的所有嵌套的用例集和用例生效，如果嵌套的用例集或者用例重写了timeout时间，则会覆盖上层的设置。通过<code>this.timeout(0)</code>，可以关掉用例或用例集的超时判断。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">describe(<span class="string">'a suite of tests'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.timeout(<span class="number">500</span>);</div><div class="line"></div><div class="line">  it(<span class="string">'should take less than 500ms'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">done</span>)</span>&#123;</div><div class="line">    setTimeout(done, <span class="number">300</span>);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  it(<span class="string">'should take less than 500ms as well'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">done</span>)</span>&#123;</div><div class="line">    setTimeout(done, <span class="number">250</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h2 id="用例执行超时"><a href="#用例执行超时" class="headerlink" title="用例执行超时"></a>用例执行超时</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">it(<span class="string">'should take less than 500ms'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">done</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.timeout(<span class="number">500</span>);</div><div class="line">  setTimeout(done, <span class="number">300</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="钩子函数超时"><a href="#钩子函数超时" class="headerlink" title="钩子函数超时"></a>钩子函数超时</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">describe(<span class="string">'a suite of tests'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  beforeEach(<span class="function"><span class="keyword">function</span>(<span class="params">done</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.timeout(<span class="number">3000</span>); <span class="comment">// A very long environment setup.</span></div><div class="line">    setTimeout(done, <span class="number">2500</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>钩子函数同样可以通过<code>this.timeout(0)</code>来关闭超时判断。</p>
<h1 id="diff差异比较功能"><a href="#diff差异比较功能" class="headerlink" title="diff差异比较功能"></a>diff差异比较功能</h1><p>若断言库抛出了AssertionErrors，且错误对象中有err.expected属性和err.actual属性，mocha会尝试在报告中展示期望的值和得到的值的差异：<br><img src="http://zoucz.com/blogimgs/2016-07-27/1469588275973.png" alt=""></p>
<h1 id="mocha使用命令和参数"><a href="#mocha使用命令和参数" class="headerlink" title="mocha使用命令和参数"></a>mocha使用命令和参数</h1><h2 id="mocha-init-初始化浏览器中测试"><a href="#mocha-init-初始化浏览器中测试" class="headerlink" title="mocha init 初始化浏览器中测试"></a>mocha init 初始化浏览器中测试</h2><p><code>mocha init</code>命令用来生成一个浏览器中单元测试的架子。<br>新建一个目录test<br><img src="http://zoucz.com/blogimgs/2016-07-27/1469588933550.png" alt=""><br>在同级目录运行命令 <code>mocha init test</code> ，可以看到test目录下生成了一些样式表文件和js脚本，以及一个用来运行用例、展示报告的index.html<br><img src="http://zoucz.com/blogimgs/2016-07-27/1469589018406.png" alt=""><br>接着使用文章开头的chai断言库，此时需要用script标签引入了，于是在index.html中加上<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://chaijs.com/chai.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>index.html内容如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Mocha<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"mocha.css"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"mocha"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://chaijs.com/chai.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"mocha.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">mocha.setup(<span class="string">'bdd'</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"tests.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line">      mocha.run();</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>test.js是一个空文件，等待我们去编写用例，在其中加上：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> assert = chai.assert;</div><div class="line">describe(<span class="string">'Array'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    describe(<span class="string">'#indexOf()'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        it(<span class="string">'should return -1 when the value is not present'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            assert.equal(<span class="number">-1</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].indexOf(<span class="number">5</span>));</div><div class="line">            assert.equal(<span class="number">-1</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].indexOf(<span class="number">0</span>));</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>在浏览器中打开index.html，可以看到用例执行报告：<br><img src="http://zoucz.com/blogimgs/2016-07-27/1469589261302.png" alt="">    </p>
<h2 id="mocha命令参数"><a href="#mocha命令参数" class="headerlink" title="mocha命令参数"></a>mocha命令参数</h2><p>mocha命令的基本格式是：<code>mocha [debug] [options] [files]</code><br>options包括下面这些，我翻译了一部分目前能理解的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">-h, --help                              输出帮助信息    </div><div class="line">-V, --version                           输出mucha版本    </div><div class="line">-A, --async-only                        强制让所有测试用例必须使用callback或者返回promise的方式来异步判断正确性    </div><div class="line">-c, --colors                            启用报告中颜色    </div><div class="line">-C, --no-colors                         禁用报告中颜色    </div><div class="line">-G, --growl                             enable growl notification support    </div><div class="line">-O, --reporter-options &lt;k=v,k2=v2,...&gt;  reporter-specific options    </div><div class="line">-R, --reporter &lt;name&gt;                   specify the reporter to use    </div><div class="line">-S, --sort                              排序测试文件    </div><div class="line">-b, --bail                              bail after first test failure    </div><div class="line">-d, --debug                             enable node&apos;s debugger, synonym for node --debug</div><div class="line">-g, --grep &lt;pattern&gt;                    只执行满足 &lt;pattern&gt;格式的用例    </div><div class="line">-f, --fgrep &lt;string&gt;                    只执行含有 &lt;string&gt; 的用例    </div><div class="line">-gc, --expose-gc                        展示gc回收的log    </div><div class="line">-i, --invert                            让 --grep 和 --fgrep 的匹配取反    </div><div class="line">-r, --require &lt;name&gt;                    require一下&lt;name&gt;指定的模块    </div><div class="line">-s, --slow &lt;ms&gt;                         指定slow时间（单位ms，默认75ms）    </div><div class="line">-t, --timeout &lt;ms&gt;                      指定超时时间（单位ms，默认2000ms）    </div><div class="line">-u, --ui &lt;name&gt;                         指定user-interface (bdd|tdd|exports)    </div><div class="line">-w, --watch                             观察用例文件变化，并重新执行    </div><div class="line">--check-leaks                           检测未回收global变量泄露    </div><div class="line">--compilers &lt;ext&gt;:&lt;module&gt;,...          用指定的模块来编译文件    </div><div class="line">--debug-brk                             启用node的debug模式    </div><div class="line">--delay                                 等待异步的用例集（见前边的）    </div><div class="line">--es_staging                            enable all staged features    </div><div class="line">--full-trace                            display the full stack trace    </div><div class="line">--globals &lt;names&gt;                       allow the given comma-delimited global [names]    </div><div class="line">--harmony                               enable all harmony features (except typeof)    </div><div class="line">--harmony-collections                   enable harmony collections (sets, maps, and weak maps)    </div><div class="line">--harmony-generators                    enable harmony generators    </div><div class="line">--harmony-proxies                       enable harmony proxies    </div><div class="line">--harmony_arrow_functions               enable &quot;harmony arrow functions&quot; (iojs)    </div><div class="line">--harmony_classes                       enable &quot;harmony classes&quot; (iojs)    </div><div class="line">--harmony_proxies                       enable &quot;harmony proxies&quot; (iojs)    </div><div class="line">--harmony_shipping                      enable all shipped harmony features (iojs)    </div><div class="line">--inline-diffs                          显示预期和实际结果的string差异比较    </div><div class="line">--interfaces                            display available interfaces    </div><div class="line">--no-deprecation                        silence deprecation warnings    </div><div class="line">--no-exit                               require a clean shutdown of the event loop: mocha will not call process.exit    </div><div class="line">--no-timeouts                           禁用timeout，可通过--debug隐式指定    </div><div class="line">--opts &lt;path&gt;                           定义option文件路径    </div><div class="line">--prof                                  显示统计信息    </div><div class="line">--recursive                             包含子目录    </div><div class="line">--reporters                             展示可用报告    </div><div class="line">--retries                               设置失败用例重试次数    </div><div class="line">--throw-deprecation                     每次调用deprecated函数的时候都抛出一个异常    </div><div class="line">--trace                                 显示函数调用栈    </div><div class="line">--trace-deprecation                     启用的时候显示调用栈    </div><div class="line">--watch-extensions &lt;ext&gt;,...            --watch监控的扩展</div></pre></td></tr></table></figure></p>
<p>下面是官方文档对部分命令的详细说明：</p>
<h3 id="W-–WATCH"><a href="#W-–WATCH" class="headerlink" title="-W, –WATCH"></a>-W, –WATCH</h3><p>用例一旦更新立即执行</p>
<h3 id="–COMPILERS"><a href="#–COMPILERS" class="headerlink" title="–COMPILERS"></a>–COMPILERS</h3><p>例如<code>--compilers coffee:coffee-script</code>编译CoffeeScript 1.6，或者<code>--compilers coffee:coffee-script/register</code>编译CoffeeScript 1.7+</p>
<h3 id="B-–BAIL"><a href="#B-–BAIL" class="headerlink" title="-B, –BAIL"></a>-B, –BAIL</h3><p>如果只对第一个抛出的异常感兴趣，可以使用此命令。</p>
<h3 id="D-–DEBUG"><a href="#D-–DEBUG" class="headerlink" title="-D, –DEBUG"></a>-D, –DEBUG</h3><p>开启nodejs的debug模式，可以在debugger语句处暂停执行。</p>
<h3 id="–GLOBALS"><a href="#–GLOBALS" class="headerlink" title="–GLOBALS "></a>–GLOBALS <names></names></h3><p>names是一个以逗号分隔的列表，如果你的模块需要暴露出一些全局的变量，可以使用此命令，例如<code>mocha  --globals app,YUI</code>。<br>这个命令还可以接受通配符，例如<code>--globals &#39;*bar</code>。参数传入 * 的话，会忽略所有全局变量。</p>
<h3 id="–CHECK-LEAKS"><a href="#–CHECK-LEAKS" class="headerlink" title="–CHECK-LEAKS"></a>–CHECK-LEAKS</h3><p>默认情况下，mocha并不会去检查应用暴露出来的全局变量，加上这个配置后就会去检查，此时某全局变量如果没有用上面的–GLOBALS去配置为可接受，mocha就会报错</p>
<h3 id="R-–REQUIRE"><a href="#R-–REQUIRE" class="headerlink" title="-R, –REQUIRE "></a>-R, –REQUIRE <module-name></module-name></h3><p>这个命令可以用来引入一些依赖的模块，比如should.js等，这个命令相当于在测试目录下每个js文件头部运行一下<code>require(&#39;should.js&#39;)</code>,模块中对Object、Array等对象的扩展会生效，也可以用<code>--require ./test/helper.js</code>这样的命令去引入指定的本地模块。<br>但是…  很鸡肋的是，如果要引用模块导出的对象，还是需要require，<code>var should = require(&#39;should&#39;)</code>这样搞。</p>
<h3 id="U-–UI"><a href="#U-–UI" class="headerlink" title="-U, –UI "></a>-U, –UI <name></name></h3><p>–ui选项可以用来指定所使用的测试接口，默认是“bdd”</p>
<h3 id="R-–REPORTER"><a href="#R-–REPORTER" class="headerlink" title="-R, –REPORTER "></a>-R, –REPORTER <name></name></h3><p>这个命令可以用来指定报告格式，默认是“spec”。可以使用第三方的报告样式，例如：<br><code>npm install mocha-lcov-reporter</code>,<code>--reporter mocha-lcov-reporter</code></p>
<h3 id="T-–TIMEOUT"><a href="#T-–TIMEOUT" class="headerlink" title="-T, –TIMEOUT "></a>-T, –TIMEOUT <ms></ms></h3><p>用来指定用例超时时间</p>
<h3 id="S-–SLOW"><a href="#S-–SLOW" class="headerlink" title="-S, –SLOW "></a>-S, –SLOW <ms></ms></h3><p>用来指定慢用例判定时间，默认是75ms</p>
<h3 id="G-–GREP"><a href="#G-–GREP" class="headerlink" title="-G, –GREP "></a>-G, –GREP <pattern></pattern></h3><p>grep pattern可以用来筛选要执行的用例或用例集，pattern参数在mocha内部会被编译成一个正则表达式。<br>假如有下面的测试用例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">describe(<span class="string">'api'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  describe(<span class="string">'GET /api/users'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    it(<span class="string">'respond with an array of users'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">describe(<span class="string">'app'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  describe(<span class="string">'GET /users'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    it(<span class="string">'respond with an array of users'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>可以用<code>--grep api</code>、<code>--grep app</code>、<code>--grep users</code>、<code>--grep GET</code>，来筛选出要执行的用例。</p>
<h1 id="测试接口类型"><a href="#测试接口类型" class="headerlink" title="测试接口类型"></a>测试接口类型</h1><p>mocha的测试接口类型指的是集中测试用例组织模式的选择，包括BDD行为驱动开发（Behavior Driven Development），TDD测试驱动开发（Test-Driven Development），Exports，QUnit 和 Require-style 几种。</p>
<h2 id="BDD"><a href="#BDD" class="headerlink" title="BDD"></a>BDD</h2><p>BDD测试接口提供 describe(), context(), it(), specify(), before(), after(), beforeEach(), 和 afterEach()几种函数，其中context函数只是describe函数的别名，specify函数也是if函数的别名。<br>mocha默认的测试接口，前边的所有例子都是基于BDD来编写的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">describe(<span class="string">'Array'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   before(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">     <span class="comment">// ...</span></div><div class="line">   &#125;);</div><div class="line"></div><div class="line">   describe(<span class="string">'#indexOf()'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">     context(<span class="string">'when not present'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">       it(<span class="string">'should not throw an error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">         (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">           [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].indexOf(<span class="number">4</span>);</div><div class="line">         &#125;).should.not.throw();</div><div class="line">       &#125;);</div><div class="line">       it(<span class="string">'should return -1'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">         [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].indexOf(<span class="number">4</span>).should.equal(<span class="number">-1</span>);</div><div class="line">       &#125;);</div><div class="line">     &#125;);</div><div class="line">     context(<span class="string">'when present'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">       it(<span class="string">'should return the index where the element first appears in the array'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">         [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].indexOf(<span class="number">3</span>).should.equal(<span class="number">2</span>);</div><div class="line">       &#125;);</div><div class="line">     &#125;);</div><div class="line">   &#125;);</div><div class="line"> &#125;);</div></pre></td></tr></table></figure></p>
<h2 id="TDD"><a href="#TDD" class="headerlink" title="TDD"></a>TDD</h2><p>TDD接口提供 suite(), test(), suiteSetup(), suiteTeardown(), setup(), 和 teardown()函数，用例写法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">suite(<span class="string">'Array'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  setup(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  suite(<span class="string">'#indexOf()'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    test(<span class="string">'should return -1 when not present'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      assert.equal(<span class="number">-1</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].indexOf(<span class="number">4</span>));</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="EXPORTS"><a href="#EXPORTS" class="headerlink" title="EXPORTS"></a>EXPORTS</h2><p>Exports 的写法有的类似于Mocha的前身expresso，其写法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">before</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="string">'Array'</span>: &#123;</div><div class="line">    <span class="string">'#indexOf()'</span>: &#123;</div><div class="line">      <span class="string">'should return -1 when not present'</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].indexOf(<span class="number">4</span>).should.equal(<span class="number">-1</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>通过exports导出的对象里边，除了几个钩子函数之外，其他的Object类型属性都是用例集，function类型的属性都是用例。</p>
<h2 id="QUNIT"><a href="#QUNIT" class="headerlink" title="QUNIT"></a>QUNIT</h2><p>像TDD接口一样支持suite和test函数，同时又像BDD一样支持before(), after(), beforeEach(), 和 afterEach()，等钩子函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ok</span>(<span class="params">expr, msg</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!expr) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(msg);</div><div class="line">&#125;</div><div class="line"></div><div class="line">suite(<span class="string">'Array'</span>);</div><div class="line"></div><div class="line">test(<span class="string">'#length'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line">  ok(arr.length == <span class="number">3</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">test(<span class="string">'#indexOf()'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line">  ok(arr.indexOf(<span class="number">1</span>) == <span class="number">0</span>);</div><div class="line">  ok(arr.indexOf(<span class="number">2</span>) == <span class="number">1</span>);</div><div class="line">  ok(arr.indexOf(<span class="number">3</span>) == <span class="number">2</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">suite(<span class="string">'String'</span>);</div><div class="line"></div><div class="line">test(<span class="string">'#length'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  ok(<span class="string">'foo'</span>.length == <span class="number">3</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="REQUIRE"><a href="#REQUIRE" class="headerlink" title="REQUIRE"></a>REQUIRE</h2><p>require测试接口允许你通过require来导入describe函数，取个任意的别名。如果你不希望测试中出现全局的变量，这个接口也是十分有用的。<br>值得注意的是，这里的require不能直接通过node命令来执行，node的模块管理是不能解析这里的require的，需要通过mocha命令来运行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">ar testCase = <span class="built_in">require</span>(<span class="string">'mocha'</span>).describe;</div><div class="line"><span class="keyword">var</span> pre = <span class="built_in">require</span>(<span class="string">'mocha'</span>).before;</div><div class="line"><span class="keyword">var</span> assertions = <span class="built_in">require</span>(<span class="string">'mocha'</span>).it;</div><div class="line"><span class="keyword">var</span> assert = <span class="built_in">require</span>(<span class="string">'chai'</span>).assert;</div><div class="line"></div><div class="line">testCase(<span class="string">'Array'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  pre(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  testCase(<span class="string">'#indexOf()'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    assertions(<span class="string">'should return -1 when not present'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      assert.equal([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].indexOf(<span class="number">4</span>), <span class="number">-1</span>);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h1 id="测试报告视图"><a href="#测试报告视图" class="headerlink" title="测试报告视图"></a>测试报告视图</h1><p>如果不自己加上自定义的报告输出，mocha会在控制台中输出报告。</p>
<h2 id="SPEC视图"><a href="#SPEC视图" class="headerlink" title="SPEC视图"></a>SPEC视图</h2><p>这个是默认的报告样式，输出一个嵌套的分级视图<br><img src="http://zoucz.com/blogimgs/2016-07-28/1469688423629.png" alt=""></p>
<h2 id="DOT-MATRIX视图"><a href="#DOT-MATRIX视图" class="headerlink" title="DOT MATRIX视图"></a>DOT MATRIX视图</h2><p>用一系列点点来表示用例，测试的是红点，未实现的是蓝点，比较慢的是黄点，通过的是白点，如果你想让报告看起来简洁一些，可以用这个视图。<br><img src="http://zoucz.com/blogimgs/2016-07-28/1469688537169.png" alt=""></p>
<h2 id="NYAN视图"><a href="#NYAN视图" class="headerlink" title="NYAN视图"></a>NYAN视图</h2><p>尼玛这是个毛线视图啊，官方文档都懒得给出说明<br><img src="http://zoucz.com/blogimgs/2016-07-28/1469688604402.png" alt=""></p>
<h2 id="TAP视图"><a href="#TAP视图" class="headerlink" title="TAP视图"></a>TAP视图</h2><p><img src="http://zoucz.com/blogimgs/2016-07-28/1469688672698.png" alt=""></p>
<h2 id="LANDING-STRIP视图"><a href="#LANDING-STRIP视图" class="headerlink" title="LANDING STRIP视图"></a>LANDING STRIP视图</h2><p> ‘Landing Strip’的意思是飞机降落跑道，这是一个逗逼测试人员弄出来的，像一架飞机降落一样的视图。<br> <img src="http://zoucz.com/blogimgs/2016-07-28/1469688878574.png" alt=""><br> 这个是坠机了的视图……<br> <img src="http://zoucz.com/blogimgs/2016-07-28/1469688898981.png" alt=""></p>
<h2 id="LIST视图"><a href="#LIST视图" class="headerlink" title="LIST视图"></a>LIST视图</h2><p>一个简单的列表视图<br><img src="http://zoucz.com/blogimgs/2016-07-28/1469688935839.png" alt=""></p>
<h2 id="PROGRESS视图"><a href="#PROGRESS视图" class="headerlink" title="PROGRESS视图"></a>PROGRESS视图</h2><p>包含一个简单的进度条的视图<br><img src="http://zoucz.com/blogimgs/2016-07-28/1469688957850.png" alt=""></p>
<h2 id="JSON视图"><a href="#JSON视图" class="headerlink" title="JSON视图"></a>JSON视图</h2><p>输出一个JSON作为测试结果<br><img src="http://zoucz.com/blogimgs/2016-07-28/1469689152790.png" alt=""></p>
<p>##JSON STREAM视图<br>输出的也是一个JSON，只不过输出的时候会带上换行<br><img src="http://zoucz.com/blogimgs/2016-07-28/1469689235837.png" alt=""></p>
<h2 id="JSONCOV覆盖率报告"><a href="#JSONCOV覆盖率报告" class="headerlink" title="JSONCOV覆盖率报告"></a>JSONCOV覆盖率报告</h2><p>一个依赖 node-jscoverage 模块生成的视图，用来生成覆盖率报告</p>
<h2 id="HTMLCOV覆盖率报告"><a href="#HTMLCOV覆盖率报告" class="headerlink" title="HTMLCOV覆盖率报告"></a>HTMLCOV覆盖率报告</h2><p>用来生成一个覆盖率的html报告<br><a href="https://github.com/expressjs/express/commit/b6ee5fafd0d6c79cf7df5560cb324ebee4fe3a7f" title="https://github.com/expressjs/express/commit/b6ee5fafd0d6c79cf7df5560cb324ebee4fe3a7f" target="_blank" rel="external">https://github.com/expressjs/express/commit/b6ee5fafd0d6c79cf7df5560cb324ebee4fe3a7f</a></p>
<h2 id="MIN视图"><a href="#MIN视图" class="headerlink" title="MIN视图"></a>MIN视图</h2><p>只显示总体测试情况<br><img src="http://zoucz.com/blogimgs/2016-07-28/1469698473893.png" alt=""></p>
<h2 id="DOC视图"><a href="#DOC视图" class="headerlink" title="DOC视图"></a>DOC视图</h2><p>生成一个只包含html的body部分的报告，结构如下：<br><img src="http://zoucz.com/blogimgs/2016-07-28/1469698544399.png" alt=""><br>例如，测试代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">describe(<span class="string">'Array'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  describe(<span class="string">'#indexOf()'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    it(<span class="string">'should return -1 when the value is not present'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].indexOf(<span class="number">5</span>).should.equal(<span class="number">-1</span>);</div><div class="line">      [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].indexOf(<span class="number">0</span>).should.equal(<span class="number">-1</span>);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>运行命令<code>mocha --reporter doc array</code>,结果：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"suite"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Array<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">dl</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"suite"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>#indexOf()<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">dl</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">dt</span>&gt;</span>should return -1 when the value is not present<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span><span class="tag">&lt;<span class="name">pre</span>&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>[1,2,3].indexOf(5).should.equal(-1);</div><div class="line">[1,2,3].indexOf(0).should.equal(-1);<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span><span class="tag">&lt;/<span class="name">dd</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>自己添加head、html等标签，再加上style，可以生成自定义样式的报告。</p>
<h2 id="MARKDOWN视图"><a href="#MARKDOWN视图" class="headerlink" title="MARKDOWN视图"></a>MARKDOWN视图</h2><p>生成一个markdown版本的报告，例子：<a href="https://github.com/senchalabs/connect/blob/90a725343c2945aaee637e799b1cd11e065b2bff/tests.md" title="https://github.com/senchalabs/connect/blob/90a725343c2945aaee637e799b1cd11e065b2bff/tests.md" target="_blank" rel="external">https://github.com/senchalabs/connect/blob/90a725343c2945aaee637e799b1cd11e065b2bff/tests.md</a></p>
<h2 id="HTML视图"><a href="#HTML视图" class="headerlink" title="HTML视图"></a>HTML视图</h2><p>目前只有在浏览器中运行的mocha才能直接生成html报告，nodejs中可以通过doc视图或者markdown视图得到的内容自己用脚本生成html版本的~<br><img src="http://zoucz.com/blogimgs/2016-07-28/1469698980933.png" alt=""></p>
<h1 id="第三方报告生成器"><a href="#第三方报告生成器" class="headerlink" title="第三方报告生成器"></a>第三方报告生成器</h1><p>mocha允许我们自己定义第三方的报告生成器，可以参考<a href="https://github.com/mochajs/mocha/wiki/Third-party-reporters" title="文档" target="_blank" rel="external">文档</a>。<br>一个例子：<a href="https://github.com/travisjeffery/mocha-teamcity-reporter" title="TeamCity reporter" target="_blank" rel="external">TeamCity reporter</a></p>
<h1 id="在浏览器中运行mocha"><a href="#在浏览器中运行mocha" class="headerlink" title="在浏览器中运行mocha"></a>在浏览器中运行mocha</h1><p>mocha项目下都会有mocha.js和mocha.css供浏览器中的测试使用</p>
<h2 id="只能在浏览器中使用的函数"><a href="#只能在浏览器中使用的函数" class="headerlink" title="只能在浏览器中使用的函数"></a>只能在浏览器中使用的函数</h2><p><code>mocha.allowUncaught()</code> ，未捕获的错误不会被抛出<br>下面是一个例子，在加载测试脚本之前，用<code>mocha.setup(&#39;bdd&#39;)</code>函数把测试模式设置为BDD接口，测试脚本加载完之后用<code>mocha.run()</code>函数来运行测试<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Mocha Tests<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"https://cdn.rawgit.com/mochajs/mocha/2.2.5/mocha.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"mocha"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.rawgit.com/jquery/jquery/2.1.4/dist/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.rawgit.com/Automattic/expect.js/0.3.1/index.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.rawgit.com/mochajs/mocha/2.2.5/mocha.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">mocha.setup(<span class="string">'bdd'</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"test.array.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"test.object.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"test.xhr.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    mocha.checkLeaks();</div><div class="line">    mocha.globals([<span class="string">'jQuery'</span>]);</div><div class="line">    mocha.run();</div><div class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="GREP"><a href="#GREP" class="headerlink" title="GREP"></a>GREP</h2><p>浏览器中可以通过在url后边加<code>?grep=api</code>参数，来使用grep命令</p>
<h2 id="浏览器中的mocha配置"><a href="#浏览器中的mocha配置" class="headerlink" title="浏览器中的mocha配置"></a>浏览器中的mocha配置</h2><p>可以通过<code>mocha.setup()</code>命令来设置配置<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Use "tdd" interface.  This is a shortcut to setting the interface;</span></div><div class="line"><span class="comment">// any other options must be passed via an object.</span></div><div class="line">mocha.setup(<span class="string">'tdd'</span>);</div><div class="line"></div><div class="line"><span class="comment">// This is equivalent to the above.</span></div><div class="line">mocha.setup(&#123;</div><div class="line">  <span class="attr">ui</span>: <span class="string">'tdd'</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// Use "tdd" interface, ignore leaks, and force all tests to be asynchronous</span></div><div class="line">mocha.setup(&#123;</div><div class="line">  <span class="attr">ui</span>: <span class="string">'tdd'</span>,</div><div class="line">  <span class="attr">ignoreLeaks</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">asyncOnly</span>: <span class="literal">true</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="浏览器中特有的选项"><a href="#浏览器中特有的选项" class="headerlink" title="浏览器中特有的选项"></a>浏览器中特有的选项</h2><h3 id="noHighlighting"><a href="#noHighlighting" class="headerlink" title="noHighlighting"></a>noHighlighting</h3><p>如果被设置为true，mocha不会尝试用高亮语法输出测试代码</p>
<h3 id="MOCHA-OPTS（mocha配置）"><a href="#MOCHA-OPTS（mocha配置）" class="headerlink" title="MOCHA.OPTS（mocha配置）"></a>MOCHA.OPTS（mocha配置）</h3><p>在服务端运行的时候，mocha会去加载test目录下的<code>mocha.opts</code>文件，来读取mocha配置项。这个配置文件中的每一行代表一项配置。如果运行mocha命令的时候，带上的配置参数与这个配置文件中的配置冲突的话，以命令中的为准。例如：<br>     –require should<br>      –reporter dot<br>      –ui bdd<br>上面的配置就会让mocha 引入一下should模块、报告样式设置为dot，并且使用bdd的测试接口。</p>
<h1 id="test-目录"><a href="#test-目录" class="headerlink" title="test/ 目录"></a>test/ 目录</h1><p>默认情况下，mocha会去当前路径下的去找 <code>./test/*.js</code>或者<code>./test/*.coffee</code>当做测试文件，所以测试文件应该放在test目录下</p>
<h1 id="编辑器插件"><a href="#编辑器插件" class="headerlink" title="编辑器插件"></a>编辑器插件</h1><p>TEXTMATE、JETBRAINS (IntelliJ IDEA, WebStorm, etc.) 等编辑器均有支持mocha测试的插件，需要使用的话请自行查阅。</p>
<h1 id="使用mocha的项目示例"><a href="#使用mocha的项目示例" class="headerlink" title="使用mocha的项目示例"></a>使用mocha的项目示例</h1><ul>
<li><a href="https://github.com/expressjs/express/tree/master/test" title="Express" target="_blank" rel="external">Express</a></li>
<li><a href="https://github.com/LearnBoost/websocket.io/tree/master/test" title="WebSocket.io" target="_blank" rel="external">WebSocket.io</a></li>
<li><a href="https://github.com/senchalabs/connect/tree/master/test" title="Connect" target="_blank" rel="external">Connect</a></li>
<li><a href="https://github.com/visionmedia/superagent/tree/master/test/node" title="SuperAgent" target="_blank" rel="external">SuperAgent</a></li>
<li><a href="https://github.com/mochajs/mocha/tree/master/test" title="Mocha" target="_blank" rel="external">Mocha</a></li>
</ul>
<p>这个是官方文档地址：<a href="http://mochajs.org/" title="http://mochajs.org/" target="_blank" rel="external">http://mochajs.org/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="关于单元测试的想法"><a href="#关于单元测试的想法" class="headerlink" title="关于单元测试的想法"></a>关于单元测试的想法</h1><p>对于一些比较重要的项目，每次更新代码之后总是要自己测好久，担心一旦上线出了问题影响的]]>
    </summary>
    
      <category term="nodejs" scheme="http://www.zoucz.com/blog/tags/nodejs/"/>
    
      <category term="单元测试" scheme="http://www.zoucz.com/blog/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
      <category term="nodejs" scheme="http://www.zoucz.com/blog/categories/nodejs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[做一个gulp+webpack+vue的单页应用开发架子]]></title>
    <link href="http://www.zoucz.com/blog/2016/07/19/gulp-webpack-vue/"/>
    <id>http://www.zoucz.com/blog/2016/07/19/gulp-webpack-vue/</id>
    <published>2016-07-19T07:06:06.000Z</published>
    <updated>2016-12-21T16:42:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="1-目标"><a href="#1-目标" class="headerlink" title="1.目标"></a>1.目标</h2><p>最近项目上的事情不多，根据我自己的开发习惯，决定开发一些简单的开发架子，方便以后事情多的时候直接套用。本文讲的一个gulp+webpack+vue的单页应用架子，想要达到的目的：</p>
<ul>
<li>可以通过命令打包开发chunk，并支持热替换</li>
<li>可以通过命令打包可发布的chunk</li>
<li>支持路由</li>
<li>路由中的代码实现按需加载</li>
<li>用CommonJs的风格组织代码</li>
<li>代码结构尽量清晰易懂    </li>
</ul>
<p>尽我所能先做出一个满足以上特点的架子吧，最近看完ES6，准备再去看看flux和reduce，看过之后再来思考下前端数据如何管理比较科学规范。架子中有做的不规范可改进的地方，烦请大家指出，我好更新。<br>首先来看一下整个架子的结构：<br><img src="http://zoucz.com/blogimgs/2016-07-19/1468898445051.png" alt=""></p>
<h2 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a>2.实现</h2><h3 id="2-1合并库文件"><a href="#2-1合并库文件" class="headerlink" title="2.1合并库文件"></a>2.1合并库文件</h3><p>库文件不会随业务代码发生变化，所以所有库文件打包成一个文件就好了，这部分代码需要直接在页面中以<code>&lt;script&gt;&lt;/script&gt;</code>标签引入，不能和业务代码打包到一起。如果和业务代码打包到一起，一旦业务代码发生变化，整个打包的文件在浏览器中都需要被重新加载，这种做法不利于客户端做缓存，也会使webpack打包业务代码的过程变得非常慢，所以这里使用gulp合并一下库文件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 合并lib文件</div><div class="line"> */</div><div class="line">gulp.task(<span class="string">'concat-lib'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    gulp.src([<span class="string">'vue/dist/vue.min.js'</span>,<span class="string">'vue-router/dist/vue-router.min.js'</span>],&#123;</div><div class="line">        <span class="attr">cwd</span>:<span class="string">'../lib'</span></div><div class="line">    &#125;).pipe(concat(<span class="string">'vue.min.js'</span>)).pipe(gulp.dest(<span class="string">'../release'</span>));</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="2-2组织业务代码"><a href="#2-2组织业务代码" class="headerlink" title="2.2组织业务代码"></a>2.2组织业务代码</h3><p>从上图可以看到，所有的业务开发代码都放在src目录下，展开来看：<br><img src="http://zoucz.com/blogimgs/2016-07-19/1468898616279.png" alt=""></p>
<ul>
<li>components目录用来存放公用的vue组件，这块架子中没有，所以是空着的</li>
<li>css用来存放所有的样式文件，modules和components目录下分别存放各模块和各个组件所使用的样式，app.css是主入口页面样式，main.css是所有样式。把样式集中起来是为了方便样式的打包。</li>
<li>modules用来存放各个模块的代码，模块的模板和js代码放在同一目录下。</li>
<li>app.js是程序主入口js，在此文件中定义单页应用的路由，指向各个模块</li>
<li>index.html是应用主页面</li>
</ul>
<p>核心代码是这块：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Vue = <span class="built_in">require</span>(<span class="string">'vue'</span>)</div><div class="line"><span class="keyword">var</span> VueRouter = <span class="built_in">require</span>(<span class="string">'vue-router'</span>);</div><div class="line">Vue.use(VueRouter);</div><div class="line"><span class="keyword">var</span> compo1=<span class="built_in">require</span>(<span class="string">'./modules/module1'</span>);</div><div class="line"><span class="built_in">require</span>(<span class="string">'./css/main.css'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 路由器需要一个根组件。</span></div><div class="line"><span class="comment">// 出于演示的目的，这里使用一个空的组件，直接使用 HTML 作为应用的模板</span></div><div class="line"><span class="keyword">var</span> App = Vue.extend(&#123;&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 创建一个路由器实例</span></div><div class="line"><span class="comment">// 创建实例时可以传入配置参数进行定制，为保持简单，这里使用默认配置</span></div><div class="line"><span class="keyword">var</span> router = <span class="keyword">new</span> VueRouter()</div><div class="line"></div><div class="line"><span class="comment">// 定义路由规则</span></div><div class="line"><span class="comment">// 每条路由规则应该映射到一个组件。这里的“组件”可以是一个使用 Vue.extend</span></div><div class="line"><span class="comment">// 创建的组件构造函数，也可以是一个组件选项对象。</span></div><div class="line"><span class="comment">// 稍后我们会讲解嵌套路由</span></div><div class="line">router.map(&#123;</div><div class="line">    <span class="string">'/'</span>: &#123;</div><div class="line">        <span class="attr">component</span>: compo1</div><div class="line">    &#125;,</div><div class="line">    <span class="string">'/path1'</span>: &#123;</div><div class="line">        <span class="attr">component</span>: compo1</div><div class="line">    &#125;,</div><div class="line">    <span class="string">'/path2'</span>: &#123;</div><div class="line">        <span class="attr">component</span>: <span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</div><div class="line">            <span class="comment">//amd规范 实现效果：</span></div><div class="line">            <span class="comment">//路由1中的模块和主页面模块打包在一起</span></div><div class="line">            <span class="comment">//路由2中的模块按需加载</span></div><div class="line">            <span class="built_in">require</span>([<span class="string">'./modules/module2'</span>],resolve);</div><div class="line">            <span class="comment">//commonJs规范实现方式:</span></div><div class="line">            <span class="comment">//require.ensure([],function(require)&#123;</span></div><div class="line">            <span class="comment">//    var comm2=require('./components/compo2');</span></div><div class="line">            <span class="comment">//    resolve(comm2)</span></div><div class="line">            <span class="comment">//&#125;);</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"><span class="comment">//默认路径</span></div><div class="line"><span class="comment">//router.go('/path1');</span></div><div class="line"><span class="comment">// 现在我们可以启动应用了！</span></div><div class="line"><span class="comment">// 路由器会创建一个 App 实例，并且挂载到选择符 #app 匹配的元素上。</span></div><div class="line">router.start(App, <span class="string">'#app'</span>)</div></pre></td></tr></table></figure></p>
<p>默认模块是moduel1，/path1路由指向module1，/path2路由指向module2，module2的模块并不是和module1一样在主页面中一开始就加载好的，而是在路由到此路径后才去加载，app.js中提供了vue组件文档中提供的两种方式：CommonJs和AMD两种规范的方式来加载，两种方式是等价的。</p>
<p><code>require(&#39;./css/main.css&#39;);</code> 把所有css加载到应用中，以便在开发模式下可以看到样式，在打包发布代码的时候会忽略此require，将样式打包成独立的文件。</p>
<h3 id="2-3打包开发代码"><a href="#2-3打包开发代码" class="headerlink" title="2.3打包开发代码"></a>2.3打包开发代码</h3><p>打包开发代码的webpack配置是build目录下的webpack.config.dev.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</div><div class="line"><span class="keyword">var</span> path=<span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"><span class="built_in">module</span>.exports=&#123;</div><div class="line">    <span class="comment">//这里写成数组是为了dev server插入服务配置</span></div><div class="line">    entry: &#123;</div><div class="line">        <span class="string">"app"</span>:[<span class="string">'../src/app.js'</span>],</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">output</span>:&#123;</div><div class="line">        <span class="attr">path</span>:path.resolve(__dirname, <span class="string">"../release"</span>),<span class="comment">//__dirname+'/../release',</span></div><div class="line">        publicPath: <span class="string">"/release/"</span>,<span class="comment">//dev server 会从此路径去拿hot-update.json</span></div><div class="line">        filename:<span class="string">'[name].bundle.js'</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">externals</span>: &#123;</div><div class="line">        <span class="string">'vue'</span>: <span class="string">'Vue'</span>,</div><div class="line">        <span class="string">'vue-router'</span>:<span class="string">'VueRouter'</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">module</span>: &#123;</div><div class="line">        <span class="attr">loaders</span>: [</div><div class="line">            &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">loader</span>: <span class="string">'style-loader!css-loader'</span> &#125;,</div><div class="line">            &#123;<span class="attr">test</span>:<span class="regexp">/\.html$/</span>,<span class="attr">loader</span>:<span class="string">'html-loader'</span>&#125;</div><div class="line">        ]</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">plugins</span>: [</div><div class="line"></div><div class="line">    ],</div><div class="line">    <span class="attr">devtool</span>: <span class="string">"source-map"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>程序主入口是app.js，所有entry只需要配置一个app.js。<br>output配置中的publicPath是用来配置项目中静态文件路径的，这里开发过程中会使用webpack-dev-server，给配置到release目录下就行了。<br>externals下面配置的是通过标签引入，可以在全局环境下访问到的变量，可以通过require这里配置的key来获取那些变量。<br><code>devtool: &quot;source-map&quot;</code> 可以为压缩之后的代码生成source-map文件，这里开发打包的代码并没有被压缩，所以这个其实没意义。<br><code>{test:/\.html$/,loader:&#39;html-loader&#39;}</code> 是用来在组件中加载html模板的：</p>
<p><img src="http://zoucz.com/blogimgs/2016-07-19/1468908847635.png" alt=""><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> template=<span class="built_in">require</span>(<span class="string">'./module1.html'</span>);</div><div class="line"><span class="comment">// 定义组件</span></div><div class="line"><span class="keyword">var</span> comm = Vue.extend(&#123;</div><div class="line">    <span class="attr">template</span>: template,</div><div class="line">    <span class="attr">data</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">items</span>:[&#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>,<span class="attr">c</span>:<span class="number">3</span>&#125;,&#123;<span class="attr">a</span>:<span class="number">4</span>,<span class="attr">b</span>:<span class="number">5</span>,<span class="attr">c</span>:<span class="number">5</span>&#125;,&#123;<span class="attr">a</span>:<span class="number">7</span>,<span class="attr">b</span>:<span class="number">8</span>,<span class="attr">c</span>:<span class="number">9</span>&#125;]</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>用上面的配置来打包，就会得到开发版本的打包代码了。</p>
<h3 id="2-4使用webpack-dev-server和热替换插件HotModuleReplacementPlugin"><a href="#2-4使用webpack-dev-server和热替换插件HotModuleReplacementPlugin" class="headerlink" title="2.4使用webpack-dev-server和热替换插件HotModuleReplacementPlugin"></a>2.4使用webpack-dev-server和热替换插件HotModuleReplacementPlugin</h3><p>为了方便开发调试，需要启动一个server来访问项目，并支持热替换，自动刷新浏览器，以方便修改代码之后能够实时看到效果。<br>在gulpfile.js做如下配置：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">ar webpackConfigDev=<span class="built_in">require</span>(<span class="string">"./webpack.config.dev.js"</span>);</div><div class="line"><span class="keyword">var</span> WebpackDevServer = <span class="built_in">require</span>(<span class="string">"webpack-dev-server"</span>);</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 使用测试配置打包，启动hot dev server</div><div class="line"> */</div><div class="line">gulp.task(<span class="string">'webpack-dev'</span>,[<span class="string">'concat-lib'</span>],<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> config = <span class="built_in">Object</span>.create(webpackConfigDev);</div><div class="line">    <span class="comment">//这两项配置原本是在webpack.config.dev.js里边配置，可是通过gulp启动devserver，那种配置无效，只能在此处写入</span></div><div class="line">    <span class="comment">//官网的解释是webpack-dev-server没有权限读取webpack的配置</span></div><div class="line">    config.entry.app.unshift(<span class="string">"webpack-dev-server/client?http://localhost:8080/"</span>, <span class="string">"webpack/hot/dev-server"</span>);</div><div class="line">    config.plugins.push(<span class="keyword">new</span> webpack.HotModuleReplacementPlugin());</div><div class="line">    <span class="keyword">var</span> compiler = webpack(config);</div><div class="line">    <span class="keyword">var</span> server = <span class="keyword">new</span> WebpackDevServer(compiler, &#123;</div><div class="line">        <span class="attr">contentBase</span>: <span class="string">"../"</span>,</div><div class="line">        <span class="attr">publicPath</span>: <span class="string">"/release/"</span>,</div><div class="line">        <span class="attr">hot</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">compress</span>: <span class="literal">false</span>,</div><div class="line">        <span class="attr">stats</span>: &#123; <span class="attr">colors</span>: <span class="literal">true</span> &#125;</div><div class="line">    &#125;);</div><div class="line">    server.listen(<span class="number">8080</span>, <span class="string">"localhost"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</div><div class="line">    <span class="comment">// server.close();</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这样会启动一个本地的8080端口监听，用来访问某个目录下的静态文件</p>
<ul>
<li><code>contentBase: &quot;../&quot;</code> 配置，指定了静态文件目录在项目根目录下，所以访问<a href="http://localhost:8080" target="_blank" rel="external">http://localhost:8080</a> 会看到根目录下的文件列表，点进去src目录，就会默认访问index.html，看到单页应用的效果了</li>
<li><code>publicPath: &quot;/release/&quot;</code> 这个配置很重要，它指定了webpack-dev-server提供的打包静态文件路径，值得注意的是，使用WebpackDevServer的时候，并不会在release目录生成webpack打包文件，只会在内存中生成打包文件，通过localhost:8080/release/ 路径，可以访问到开发打包后的代码。<br>通过gulp启动此server之后，访问<a href="http://localhost:8080/src" target="_blank" rel="external">http://localhost:8080/src</a> 路径，可以看到用下面的效果：</li>
</ul>
<p><img src="http://zoucz.com/blogimgs/2016-07-19/vuegif.gif" alt=""><br>可以看到，访问主页面的时候，加载了app.bundle.js打包文件，访问路由/path2的时候，才会去加载1.1.bundle.js文件，子组件是延迟2s后才加载的。<br>更新代码之后，会实时打包并刷新浏览器，看到实时效果。</p>
<h3 id="2-5打包生产环境代码"><a href="#2-5打包生产环境代码" class="headerlink" title="2.5打包生产环境代码"></a>2.5打包生产环境代码</h3><p>和开发代码不同，生产环境代码具有以下特点：</p>
<ul>
<li>代码需要压缩</li>
<li>打包生成的文件名中需要包含文件hash值，以方便控制客户端缓存</li>
<li>css不能像开发环境那样打包到js代码中，需要打包成独立的文件，在页面开头直接引入<br>基于以上特点，webpack配置文件如下：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</div><div class="line"><span class="keyword">var</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">"extract-text-webpack-plugin"</span>);</div><div class="line"><span class="keyword">var</span> path=<span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"><span class="keyword">var</span> cssExtract=<span class="keyword">new</span> ExtractTextPlugin(<span class="string">"[name].[contenthash:8].css"</span>);</div><div class="line"><span class="built_in">module</span>.exports=&#123;</div><div class="line">    <span class="attr">entry</span>: &#123;</div><div class="line">        <span class="attr">index</span>:<span class="string">'../src/app.js'</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">output</span>:&#123;</div><div class="line">        <span class="attr">path</span>:path.resolve(__dirname, <span class="string">"../release"</span>),</div><div class="line">        <span class="attr">publicPath</span>:<span class="string">""</span>,<span class="comment">//TODO 填写生产环境静态文件路径</span></div><div class="line">        filename:<span class="string">'[name].[chunkhash:8].bundle.js'</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">externals</span>: &#123;</div><div class="line">        <span class="string">'vue'</span>: <span class="string">'Vue'</span>,</div><div class="line">        <span class="string">'vue-router'</span>:<span class="string">'VueRouter'</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">module</span>: &#123;</div><div class="line">        <span class="attr">loaders</span>: [</div><div class="line">            &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">loader</span>: cssExtract.extract(<span class="string">"style-loader"</span>, <span class="string">"css-loader"</span>) &#125;,</div><div class="line">            &#123;<span class="attr">test</span>:<span class="regexp">/\.html$/</span>,<span class="attr">loader</span>:<span class="string">'html-loader'</span>&#125;</div><div class="line">        ]</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">plugins</span>: [</div><div class="line">        <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;</div><div class="line">            <span class="attr">compress</span>: &#123;</div><div class="line">                <span class="attr">drop_console</span>: <span class="literal">true</span>,</div><div class="line">                <span class="attr">warnings</span>: <span class="literal">false</span></div><div class="line">            &#125;</div><div class="line">        &#125;),</div><div class="line">        cssExtract</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>其中publicPath是填写静态文件路径的，如果图片或其他静态资源需要存放在CDN服务器上，可以把CDN地址配置到这里。<br>生成打包文件之后，可以通过gulp替换掉主入口文件 index.html里面的静态文件路径，这里通过webpack模板也可以完成此工作，但配置较为繁琐，个人感觉还是通过gulp来替换比较方便一点：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gulp.src(<span class="string">'../src/index.html'</span>)</div><div class="line">        <span class="comment">//.pipe(greplace(/xxxxx/g,"xxxxx"))</span></div><div class="line">        .pipe(gulp.dest(<span class="string">'../release'</span>));</div></pre></td></tr></table></figure></p>
<p>打包后的代码：<br><img src="http://zoucz.com/blogimgs/2016-07-19/1468911336639.png" alt=""><br>后面的步骤就是上传静态文件到CDN或其他上线流程了，这里可以通过根据自己业务编写的gulp插件来完成，大家业务不同，处理方式不尽相同，我就不继续往下写了。</p>
<h2 id="3-把命令都整合到npm中"><a href="#3-把命令都整合到npm中" class="headerlink" title="3.把命令都整合到npm中"></a>3.把命令都整合到npm中</h2><p>我个人不太喜欢项目根目录下一堆跟打包相关的文件，所以在这个项目中，我把所有跟打包相关的文件都放到了build目录下，然后在package.json中：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">"scripts": &#123;</div><div class="line">    "dev": "gulp default --gulpfile build/gulpfile.js",</div><div class="line">    "build": "gulp build --gulpfile build/gulpfile.js",</div><div class="line">    "release": "gulp release --gulpfile build/gulpfile.js"</div><div class="line">  &#125;,</div></pre></td></tr></table></figure></p>
<p>这样就可以使用npm命令来执行上面的操作了：<br><code>npm run dev</code> 启动webpack-dev-server，使用开发webpack配置来打包代码，支持热替换<br><code>npm run build</code> 打包开发代码<br><code>npm run release</code> 打包生产环境代码</p>
<h2 id="4-后续"><a href="#4-后续" class="headerlink" title="4.后续"></a>4.后续</h2><p>对于一个可用单页应用而言，这个架子可能还缺着很多东西，对前端数据流程的管理、网络请求的管理、公共组件的组织等，在以后的项目中都会加上这些东西，用到了再往里边更新吧！</p>
<p>代码地址：<a href="https://github.com/zouchengzhuo/scaffold/tree/master/gulp-webpack-vue" target="_blank" rel="external">https://github.com/zouchengzhuo/scaffold/tree/master/gulp-webpack-vue</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1-目标"><a href="#1-目标" class="headerlink" title="1.目标"></a>1.目标</h2><p>最近项目上的事情不多，根据我自己的开发习惯，决定开发一些简单的开发架子，方便以后事情多的时候直接套用。本文讲的一个gulp+]]>
    </summary>
    
      <category term="gulp" scheme="http://www.zoucz.com/blog/tags/gulp/"/>
    
      <category term="webpack" scheme="http://www.zoucz.com/blog/tags/webpack/"/>
    
      <category term="vue" scheme="http://www.zoucz.com/blog/tags/vue/"/>
    
      <category term="前端开发" scheme="http://www.zoucz.com/blog/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自己实现一个javascript事件模块]]></title>
    <link href="http://www.zoucz.com/blog/2016/07/01/czevent/"/>
    <id>http://www.zoucz.com/blog/2016/07/01/czevent/</id>
    <published>2016-07-01T04:08:44.000Z</published>
    <updated>2016-12-21T16:42:00.000Z</updated>
    <content type="html"><![CDATA[<h3 id="nodejs中的事件模块"><a href="#nodejs中的事件模块" class="headerlink" title="nodejs中的事件模块"></a>nodejs中的事件模块</h3><p>nodejs中有一个events模块，用来给别的函数对象提供绑定事件、触发事件的能力。这个别的函数的对象，我把它叫做事件宿主对象（非权威叫法），其原理是把宿主函数的原型链指向时间模块的一个对象，做一个函数继承，让宿主函数也拥有处理事件的能力<br>使用nodejs事件模块的demo如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</div><div class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyEmitter</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    EventEmitter.call(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line">util.inherits(MyEmitter, EventEmitter);</div><div class="line"></div><div class="line"><span class="keyword">var</span> myEmitter = <span class="keyword">new</span> MyEmitter();</div><div class="line">myEmitter.on(<span class="string">"hehe"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"hehe"</span>)</div><div class="line">&#125;)</div><div class="line">myEmitter.on(<span class="string">"hehe"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"haha"</span>)</div><div class="line">&#125;)</div><div class="line">myEmitter.emit(<span class="string">"hehe"</span>);</div><div class="line"><span class="built_in">console</span>.log(myEmitter.listeners(<span class="string">"hehe"</span>));</div></pre></td></tr></table></figure></p>
<p>看node events的api <a href="http://nodejs.cn/api/events.html" target="_blank" rel="external">http://nodejs.cn/api/events.html</a> ，一个事件模块需要具备如下的基本功能：</p>
<ul>
<li>添加绑定事件</li>
<li>添加绑定一次性事件</li>
<li>移除事件监听</li>
<li>触发事件</li>
<li>其他需要的扩展</li>
</ul>
<h3 id="事件模块设计"><a href="#事件模块设计" class="headerlink" title="事件模块设计"></a>事件模块设计</h3><p>俗话说得好，不会造轮子的车手不是一个老司机！自己实现一个简单的事件系统，实现上面几个基本的功能就行。<br>捋一捋思路，我们需要先实现一个事件类，用来创建不同名称的事件对象，例如click事件对象，hehe事件对象等，并在对象内部维持一个事件被触发时的处理函数列表。<br>对于同一个事件宿主对象而言，对它绑定的事件应该有如下特点：</p>
<ol>
<li>同一种类型的事件对象只需要有一个</li>
<li>处理函数需要有多个</li>
<li>对于同一个事件，重复绑定同一个事件处理函数应该是无效的</li>
</ol>
<p>于是得到如下结构：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 定义一个事件单元类</div><div class="line"> * @param eventname</div><div class="line"> * @constructor</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventMeta</span>(<span class="params">eventname</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name=eventname;</div><div class="line">    <span class="keyword">this</span>.handlerMap=&#123;&#125;;</div><div class="line">    <span class="keyword">this</span>.handlerList=[];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>每个事件宿主对象都应该自己持有一个map，用来保存自己的事件单元对象，加上上面所说的，绑定，一次性绑定、解绑、触发，宿主函数的原型应该被指向这样一个对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> prototype=&#123;</div><div class="line">       <span class="attr">addEventListener</span>:addEventListener,</div><div class="line">       <span class="attr">once</span>:once,</div><div class="line">       <span class="attr">removeEventListener</span>:removeEventListener,</div><div class="line">       <span class="attr">trigger</span>:trigger,</div><div class="line">       <span class="attr">getEventHandlerMap</span>:getEventHandlerMap</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>为了让宿主函数拥有这些属性，需要一个函数来为宿主函数指一下prototype属性，这里要注意的是，一定要调用这个函数之后，再扩展宿主函数自身的prototype属性，否则会被覆盖<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">czEvent</span>(<span class="params">fn</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> fn!==<span class="string">"function"</span>) <span class="keyword">return</span>;</div><div class="line">        fn.prototype=<span class="built_in">Object</span>.create(prototype);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>用户使用的时候这样调用一下就可以了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> czEvent=<span class="built_in">require</span>(<span class="string">"../czEvent"</span>);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyEmitter</span>(<span class="params"></span>) </span>&#123;</div><div class="line">&#125;</div><div class="line">czEvent(MyEmitter);</div></pre></td></tr></table></figure></p>
<h3 id="依次实现事件函数"><a href="#依次实现事件函数" class="headerlink" title="依次实现事件函数"></a>依次实现事件函数</h3><h4 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener"></a>addEventListener</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 绑定事件监听</div><div class="line"> * @param type</div><div class="line"> * @param handler</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEventListener</span>(<span class="params">eventname,handler</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> EventHandlerMap=<span class="keyword">this</span>.getEventHandlerMap();</div><div class="line">    <span class="keyword">var</span> meta=EventHandlerMap[eventname];</div><div class="line">    <span class="keyword">if</span>(!meta)&#123;</div><div class="line">        meta=EventHandlerMap[eventname]=<span class="keyword">new</span> EventMeta(eventname);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> handlerId=handler.__handlerId;</div><div class="line">    <span class="keyword">if</span>(!handlerId)&#123;</div><div class="line">        EventHandlerMap.__handlerId++;</div><div class="line">        handler.__handlerId=EventHandlerMap.__handlerId;</div><div class="line">        handlerId=handler.__handlerId;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//对于同一事件的同一处理函数，不重复绑定</span></div><div class="line">    <span class="keyword">if</span>(!meta.handlerMap[handlerId])&#123;</div><div class="line">        meta.handlerMap[handlerId]=handler;</div><div class="line">        meta.handlerList.push(handler);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="once"><a href="#once" class="headerlink" title="once"></a>once</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 绑定只执行一次的handler</div><div class="line"> * @param type</div><div class="line"> * @param handler</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">once</span>(<span class="params">eventname,handler</span>)</span>&#123;</div><div class="line">    handler.__once=<span class="literal">true</span>;</div><div class="line">    <span class="keyword">this</span>.addEventListener(eventname,handler);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="removeEventListener"><a href="#removeEventListener" class="headerlink" title="removeEventListener"></a>removeEventListener</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 移除事件监听</div><div class="line"> * @param type</div><div class="line"> * @param handdler</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeEventListener</span>(<span class="params">eventname,handdler</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> EventHandlerMap=<span class="keyword">this</span>.getEventHandlerMap();</div><div class="line">    <span class="keyword">var</span> meta=EventHandlerMap[eventname];</div><div class="line">    <span class="keyword">if</span>(!meta) <span class="keyword">return</span>;</div><div class="line">    <span class="comment">//移除一个handler的绑定</span></div><div class="line">    <span class="keyword">if</span>(handdler &amp;&amp; handdler.__handlerId)&#123;</div><div class="line">        <span class="keyword">var</span> index=meta.handlerList.indexOf(handdler);</div><div class="line">        <span class="keyword">if</span>(index&gt;<span class="number">-1</span>)&#123;</div><div class="line">            meta.handlerList.splice(index,<span class="number">1</span>);</div><div class="line">            <span class="keyword">delete</span> meta.handlerMap[handdler.__handlerId];</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//移除所有handler</span></div><div class="line">    meta.handlerMap=&#123;&#125;;</div><div class="line">    meta.handlerList.length=<span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="trigger"><a href="#trigger" class="headerlink" title="trigger"></a>trigger</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 触发事件</div><div class="line"> * @param eventname</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> EventHandlerMap=<span class="keyword">this</span>.getEventHandlerMap();</div><div class="line">    <span class="keyword">var</span> args=[];</div><div class="line">    <span class="keyword">var</span> that=<span class="keyword">this</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="built_in">arguments</span>.length;i++)&#123;</div><div class="line">        args.push(<span class="built_in">arguments</span>[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> eventname=args.splice(<span class="number">0</span>,<span class="number">1</span>);</div><div class="line">    <span class="keyword">var</span> meta=EventHandlerMap[eventname];</div><div class="line">    <span class="keyword">if</span>(!meta) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">var</span> onceHandlerList=[];</div><div class="line">    <span class="comment">//依次同步执行handler</span></div><div class="line">    meta.handlerList.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">handler</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(handler.__once)&#123;</div><div class="line">            onceHandlerList.push(handler)</div><div class="line">        &#125;</div><div class="line">        handler.apply(<span class="keyword">this</span>,args);</div><div class="line">    &#125;);</div><div class="line">    <span class="comment">//清除绑定为once的事件</span></div><div class="line">    onceHandlerList.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">handler</span>)</span>&#123;</div><div class="line">        that.removeEventListener(eventname,handler);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="getEventHandlerMap"><a href="#getEventHandlerMap" class="headerlink" title="getEventHandlerMap"></a>getEventHandlerMap</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getEventHandlerMap</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> EventHandlerMap=<span class="keyword">this</span>.__EventHandlerMap;</div><div class="line">    <span class="keyword">if</span>(EventHandlerMap) <span class="keyword">return</span> EventHandlerMap;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.__EventHandlerMap=&#123;<span class="attr">__handlerId</span>:<span class="number">0</span>&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="包装"><a href="#包装" class="headerlink" title="包装"></a>包装</h3><p>学(chao)习(xi)一下jquery的包装技术，让模块支持commonJs和amd<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by czzou on 2016/6/30.</div><div class="line"> */</div><div class="line">( <span class="function"><span class="keyword">function</span>(<span class="params"> global, factory </span>) </span>&#123;</div><div class="line"><span class="meta">    "use strict"</span>;</div><div class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">"object"</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span>.exports === <span class="string">"object"</span> ) &#123;</div><div class="line">        <span class="built_in">module</span>.exports = factory( global, <span class="literal">true</span> );</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        factory( global );</div><div class="line">    &#125;</div><div class="line">&#125;(<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">"undefined"</span> ? <span class="built_in">window</span> : <span class="keyword">this</span>,<span class="function"><span class="keyword">function</span>(<span class="params">window,noGlobal</span>)</span>&#123;</div><div class="line">	<span class="comment">//把上面的代码copy进来</span></div><div class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> define === <span class="string">"function"</span> &amp;&amp; define.amd ) &#123;</div><div class="line">        define( <span class="string">"czEvent"</span>, [], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> czEvent;</div><div class="line">        &#125; );</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> ( !noGlobal ) &#123;</div><div class="line">        <span class="built_in">window</span>.czEvent = czEvent;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> czEvent;</div><div class="line">&#125;))</div></pre></td></tr></table></figure></p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>如有需求，还可以在此基础上进行一些扩展，比如nodejs的events模块支持的handler函数个数上限、handler函数抛出异常时触发的error事件等，另外，简单改写一下czEvent函数，还可以让事件模块支持给对象赋予事件处理能力的功能<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">czEvent</span>(<span class="params">fn,asObj</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(asObj)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> prototype)&#123;</div><div class="line">            <span class="built_in">Object</span>.defineProperty(fn,key,&#123;</div><div class="line">                <span class="attr">value</span>:prototype[key]</div><div class="line">            &#125;)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> fn!==<span class="string">"function"</span>) <span class="keyword">return</span>;</div><div class="line">    fn.prototype=<span class="built_in">Object</span>.create(prototype);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>分别测试nodejs的events模块，czEvent的commonJs用法，amd用法以及直接引用用法，demo就不在这里一一列举了~<br><img src="http://zoucz.com/blogimgs/2016-07-01/1467344448737.png" alt=""></p>
<p>github地址：<a href="https://github.com/zouchengzhuo/czevent" title="https://github.com/zouchengzhuo/czevent" target="_blank" rel="external">https://github.com/zouchengzhuo/czevent</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="nodejs中的事件模块"><a href="#nodejs中的事件模块" class="headerlink" title="nodejs中的事件模块"></a>nodejs中的事件模块</h3><p>nodejs中有一个events模块，用来给别的函数对象提供]]>
    </summary>
    
      <category term="event" scheme="http://www.zoucz.com/blog/tags/event/"/>
    
      <category term="javascript" scheme="http://www.zoucz.com/blog/categories/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[nodejs中获取时间戳、时间差]]></title>
    <link href="http://www.zoucz.com/blog/2016/06/28/nodejs-get-time/"/>
    <id>http://www.zoucz.com/blog/2016/06/28/nodejs-get-time/</id>
    <published>2016-06-28T03:03:36.000Z</published>
    <updated>2016-12-21T16:42:00.000Z</updated>
    <content type="html"><![CDATA[<p>Nodejs中获取时间戳的方法有很多种，例如：<br><code>new Date().getTime()</code><br><code>Date.now()</code><br><code>process.uptime()</code><br><code>process.hrtime()</code><br>平时想获取一个时间戳的话，用这些方法都可以,那么这些方法有什么区别呢？</p>
<h2 id="new-Date-getTime-和Date-now"><a href="#new-Date-getTime-和Date-now" class="headerlink" title="new Date().getTime()和Date.now()"></a>new Date().getTime()和Date.now()</h2><p>这些方法是通过node运行环境的系统时间毫秒数,<code>+new Date()</code>写法的效果和<code>new Date().getTime()</code>效果相同。<br>在需要频繁使用时间戳的场景中，需要关注方法性能，这几种方法中<code>Date.now()</code>的性能最佳，可以通过一点代码来测试：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> t1 = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</div><div class="line"><span class="keyword">var</span> t2 = t1;</div><div class="line"><span class="keyword">var</span> i = <span class="number">0</span>, count = <span class="number">10000000</span>, interval = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count; i++)</div><div class="line">&#123;</div><div class="line">    t2 = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</div><div class="line">    interval = (t2 - t1);</div><div class="line">&#125;</div><div class="line">interval = (t2 - t1);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'【new Date().getTime()】interval: '</span>, interval);</div><div class="line"></div><div class="line">t1 = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</div><div class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count; i++)</div><div class="line">&#123;</div><div class="line">    t2 = +<span class="keyword">new</span> <span class="built_in">Date</span>;</div><div class="line">    interval = (t2 - t1);</div><div class="line">&#125;</div><div class="line">interval = (t2 - t1);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'【+new Date】interval: '</span>, interval);</div><div class="line"></div><div class="line">t1 = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</div><div class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count; i++)</div><div class="line">&#123;</div><div class="line">    t2 = <span class="built_in">Date</span>.now();</div><div class="line">    interval = (t2 - t1);</div><div class="line">&#125;</div><div class="line">interval = (t2 - t1);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'【Date.now()】interval: '</span>, interval);</div></pre></td></tr></table></figure></p>
<p>输出结果：<br>        【new Date().getTime()】interval:  1583<br>        【+new Date】interval:  2189<br>        【Date.now()】interval:  891</p>
<p>如果只是获取时间戳，那么使用Date.now()是最佳的做法，但是如果要计算时间差，这几个方法就会有点问题：运行环境的系统时间有时候是会有微小回调的，这样得到的时间差就不精确了，有时候会引发某些BUG。</p>
<h2 id="process-hrtime"><a href="#process-hrtime" class="headerlink" title="process.hrtime()"></a>process.hrtime()</h2><p>这种方式是根据任意取的一个过去的时间点，距离现在的时间来获取一个精确的时间戳对象：[秒, 纳秒]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; process.hrtime()</div><div class="line">[ <span class="number">3197146</span>, <span class="number">563552237</span> ]</div></pre></td></tr></table></figure></p>
<p>这种方式和系统时间无关，因此不会受到系统时钟漂移的影响，用来计算时间差的时候就不会有BUG了。<br>但是，万事总有但是 - -<br>如果用在一个被频繁调用的地方呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> t1 = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</div><div class="line"><span class="keyword">var</span> t2 = t1;</div><div class="line"><span class="keyword">var</span> i = <span class="number">0</span>, count = <span class="number">10000000</span>, interval = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> hrTime1 = process.hrtime();</div><div class="line"><span class="keyword">var</span> hrTime2 = hrTime1;</div><div class="line"></div><div class="line">t1 = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</div><div class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count; i++)</div><div class="line">&#123;</div><div class="line">    hrTime2 = process.hrtime(hrTime1);</div><div class="line">&#125;</div><div class="line">t2 = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</div><div class="line">interval = <span class="built_in">parseInt</span>(hrTime2[<span class="number">0</span>] * <span class="number">1e3</span> + hrTime2[<span class="number">1</span>] * <span class="number">1e-6</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'【hrTime】interval: '</span>, interval, t2 - t1);</div></pre></td></tr></table></figure></p>
<p>【hrTime】interval:  6412 6413<br>没有记错的话，相同的创建次数，上面的Date.now()可是900ms左右啊！<br>process.hrtime()也太慢了有木有！！！<br>原来nodejs处理高精度时间的时候，计算比较复杂，占用系统资源多，速度慢，那么在高频应用的地方就不适合用这个方法了。下面请看process.uptime()</p>
<h2 id="process-uptime（）"><a href="#process-uptime（）" class="headerlink" title="process.uptime（）"></a>process.uptime（）</h2><p>此函数是通过nodejs启动运行时间来得到一个秒数时间戳，精确到毫秒：<br><code>process.uptime</code><br>输入：6.419<br>此函数以node启动时间为准，同样也不会受系统时钟漂移影响，适合用来计算时间差。<br>那么多次调用性能如何呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> t1 = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</div><div class="line"><span class="keyword">var</span> t2 = t1;</div><div class="line"><span class="keyword">var</span> i = <span class="number">0</span>, count = <span class="number">10000000</span>, interval = <span class="number">0</span>;</div><div class="line"></div><div class="line">t1 = process.uptime()*<span class="number">1000</span>;</div><div class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count; i++)</div><div class="line">&#123;</div><div class="line">    t2 = process.uptime()*<span class="number">1000</span>;</div><div class="line">    <span class="comment">//interval = (t2 - t1);</span></div><div class="line">&#125;</div><div class="line">interval = (t2 - t1);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'【process.uptime()】interval: '</span>, interval);</div></pre></td></tr></table></figure></p>
<p>输出：【process.uptime()】interval:  954</p>
<p>和process.hrtime()相比性能就搞出很多了~<br>不用算那么精确，就是快！<br>那么需要高频计算时间差的场合，就是你了！</p>
<p>测试代码地址：<a href="https://github.com/zouchengzhuo/nodejsLearn/tree/master/getTime" target="_blank" rel="external">https://github.com/zouchengzhuo/nodejsLearn/tree/master/getTime</a></p>
<p>【end】</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Nodejs中获取时间戳的方法有很多种，例如：<br><code>new Date().getTime()</code><br><code>Date.now()</code><br><code>process.uptime()</code><br><code>process]]>
    </summary>
    
      <category term="nodejs" scheme="http://www.zoucz.com/blog/tags/nodejs/"/>
    
      <category term="nodejs" scheme="http://www.zoucz.com/blog/categories/nodejs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[理解npm-shrinkwrap]]></title>
    <link href="http://www.zoucz.com/blog/2016/06/27/npm-shrinkwrap/"/>
    <id>http://www.zoucz.com/blog/2016/06/27/npm-shrinkwrap/</id>
    <published>2016-06-26T18:10:20.000Z</published>
    <updated>2016-12-21T16:42:00.000Z</updated>
    <content type="html"><![CDATA[<p>本文转自美团技术博客，原文：<a href="http://tech.meituan.com/npm-shrinkwrap.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">http://tech.meituan.com/npm-shrinkwrap.html?utm_source=tuicool&amp;utm_medium=referral</a>  </p>
<p>管理依赖是一个复杂软件开发过程中必定会遇到的问题。    </p>
<p>在Node.js项目开发的时候，我们也经常需要安装和升级对应的依赖。虽然 npm 以及语意化的版本号 (semantic versioning, semver) 让开发过程中依赖的获取和升级变得非常容易， 但不严格的版本号限制，也带来了版本号的不确定性。主要的问题可能有三个：    </p>
<ol>
<li><p>npm 建议使用 semver 的应用程序版本，但这也完全依赖第三方包遵守这一规则。如果你依赖于的包不遵循 semver ，或者依赖的包的新版本有重大更改（而你使用了 ^ 的宽泛版本安装），这潜在可能是会导致问题的。    </p>
</li>
<li><p>另一个问题的出现是由于 npm 安装依赖的机制。npm 的安装包是有层次结构的，手动控制要安装的软件包的版本号可以实现，但是你只能在 package.json 使用精确的版本号控制你的直接依赖包，但那些多层以上的依赖就没办法控制了；一个第三方包不严谨的版本依赖生命可能破坏你的依赖管理。    </p>
</li>
<li><p>在开发阶段执行得到的版本，和后续部署时得到的可能是不一致的，更不可控的是，你依赖的第三方包也有这样的情况会导致潜在的上线风险。 CaseStudy-20150804-优惠买单 C 端服务挂掉无法重启 就是性能平台 SDK 依赖的包版本号不固定导致的。    </p>
</li>
</ol>
<p>如果要控制上线的风险，我们就必需要解决这个问题，这时候，就需要使用 npm shrinkwrap 这个命令来解决问题。  </p>
<h2 id="介绍-shrinkwrap"><a href="#介绍-shrinkwrap" class="headerlink" title="介绍 shrinkwrap"></a>介绍 shrinkwrap</h2><p>npm shrinkwrap 可以按照当前项目 node_modules 目录内的安装包情况生成稳定的版本号描述。  </p>
<p>比方说，有一个包 A  </p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	<span class="attr">"name"</span>: <span class="string">"A"</span>,</div><div class="line">	<span class="attr">"version"</span>: <span class="string">"0.1.0"</span>,</div><div class="line">	<span class="attr">"dependencies"</span>: &#123;</div><div class="line">		<span class="attr">"B"</span>: <span class="string">"\&lt;0.1.0"</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有一个包 B</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	<span class="attr">"name"</span>: <span class="string">"B"</span>,</div><div class="line">	<span class="attr">"version"</span>: <span class="string">"0.0.1"</span>,</div><div class="line">	<span class="attr">"dependencies"</span>: &#123;</div><div class="line">		<span class="attr">"C"</span>: <span class="string">"\&lt;0.1.0"</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以及包 C<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	<span class="attr">"name"</span>: <span class="string">"C"</span>,</div><div class="line">	<span class="attr">"version"</span>: <span class="string">"0.0.1"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你的项目只依赖于 A，于是 npm install 会得到这样的目录结构  </p>
<pre><code>A@0.1.0
    -- B@0.0.1
        -- C@0.0.1
</code></pre><p>这时候，B@0.0.2 发布了，这时候在一个新的环境下执行 npm install 将得到  </p>
<pre><code>A@0.1.0
    -- B@0.0.2
        -- C@0.0.1
</code></pre><p>这时候两次安装得到的版本号就不一致了。而通过 shrinkwrap 命令，我们可以保证在所有环境下安装得到稳定的结果。</p>
<p>在项目引入新包的时候，或者 A 的开发者执行一下 npm shrinkwrap ，可以在项目根目录得到一个 npm-shrinkwrap.json 文件。</p>
<p>这个文件内容如下<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">   <span class="attr">"name"</span>: <span class="string">"A"</span>,</div><div class="line">   <span class="attr">"version"</span>: <span class="string">"0.1.0"</span>,</div><div class="line">   <span class="attr">"dependencies"</span>: &#123;</div><div class="line">    <span class="attr">"B"</span>: &#123;</div><div class="line">       <span class="attr">"version"</span>: <span class="string">"0.0.1"</span>,</div><div class="line">       <span class="attr">"dependencies"</span>: &#123;</div><div class="line">         <span class="attr">"C"</span>: &#123;</div><div class="line">           <span class="attr">"version"</span>: <span class="string">"0.0.1"</span></div><div class="line">         &#125;</div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>shrinkwrap 命令根据目前安装在node_modules的文件情况锁定依赖版本。在项目中执行 npm install 的时候，npm 会检查在根目录下有没有 npm-shrinkwrap.json 文件，如果 shrinkwrap 文件存在的话，npm 会使用它（而不是 package.json）来确定安装的各个包的版本号信息。</p>
<p>这样一来，在安装时候确定的所有版本信息会稳定的固化在 shrinkwrap 里。无论是A，B 和 C中的版本如何变化，或者它们的 package.json 文件如何修改，你始终能保证，在你项目中执行 npm install 的到的版本号时稳定的。</p>
<h2 id="在开发中使用-shrinkwrap"><a href="#在开发中使用-shrinkwrap" class="headerlink" title="在开发中使用 shrinkwrap"></a>在开发中使用 shrinkwrap</h2><p>在开发过程中，引入一个新包的流程如下</p>
<ol>
<li>npm install PACKAGE_NAME@VERSION –save 获取特定版本的包</li>
<li>测试功能</li>
<li>测试功能正常后，执行 npm shrinkwrap 把依赖写入 shrinkwrap 文件</li>
<li>在代码仓库中提交 shrinkwrap / package.json 描述</li>
</ol>
<p>升级一个包的流程应该是这样</p>
<ol>
<li>npm outdated 获取项目所有依赖的更新信息</li>
<li>npm install PACKAGE_NAME@VERSION –save 获取特定版本的包</li>
<li>测试功能</li>
<li>测试功能正常后，执行 npm shrinkwrap 把依赖写入 shrinkwrap 文件</li>
<li>在代码仓库中提交 shrinkwrap / package.json 描述</li>
</ol>
<p>删除一个包的流程如下</p>
<ol>
<li>npm uninstall PACKAGE_NAME –save 删除这个包</li>
<li>测试功能</li>
<li>测试功能正常后，执行 npm shrinkwrap 把更新的依赖写入 shrinkwrap 文件</li>
<li>在代码仓库中提交 shrinkwrap / package.json 描述</li>
<li>比一般的安装多了一步手工生成 shrinkwrap 文件。在实际工作中，有时候我们会忘记这一步，导致上线时候没有获取到依赖包的特定版本。</li>
</ol>
<h1 id="介绍-npm-shrinkwrap-install"><a href="#介绍-npm-shrinkwrap-install" class="headerlink" title="介绍 npm-shrinkwrap-install"></a>介绍 npm-shrinkwrap-install</h1><p>去年我引入 shrinkwrap 工作流的时候，npm 官方的 shrinkwrap 命令还有很多问题，比如  </p>
<ul>
<li>在生成版本描述的时候不会忽略 devDependencies 和 optionalDependencies  </li>
<li>不会检查 package.json 和 shrinkwrap 文件的差异</li>
<li>不会删除 from 字段（这个字段没有用），导致在 diff 时候会出现多余的信息  </li>
</ul>
<p>所以我写了一个<a href="http://git.sankuai.com/projects/FE/repos/fe-paidui/browse/bin/shrinkwrap" target="_blank" rel="external"> bin/shrinkwrap</a> 脚本 。这个脚本会自动对比 package.json 和 npm-shrinkwrap.json 文件的区别，获取需要更新的版本，然后对相关信息进行更新。(更新：现在的 npm shrinkwrap 已经修复了很多的问题，但 from 字段有时候仍然有些小问题。）</p>
<p>当时为了忽略 devDependencies 和 optionalDependencies，我会执行 npm prune 删除额外的包之后才生成版本描述，然后再把其它的包装回来，导致脚本执行时间有点长。</p>
<p>后面 uber 发布了 <a href="https://github.com/uber/npm-shrinkwrap" target="_blank" rel="external">npm-shrinkwrap</a> 工具 ，可以更高效的生成版本描述。可惜这个包不支持 scoped package。我花了一点时间 patch 了这个工具，因为它们的发版太慢，所以我发布了一份 <a href="https://www.npmjs.com/package/@th507/npm-shrinkwrap" target="_blank" rel="external">@th507/npm-shrinkwrap</a> ，可以支持 scoped package。</p>
<p>在上面这个包的基础上，我还写了另外一个小工具，叫做<a href="https://github.com/th507/npm-shrinkwrap-install" target="_blank" rel="external"> npm-shrinkwrap-install</a> ，它可以无缝替换 npm install 的执行过程，让 shrinkwrap 文件的生成变得更自动。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>$ npm install npm-shrinkwrap-install</code></p>
<p>安装完成之后，有如下命令可以使用</p>
<h3 id="安装依赖的命令"><a href="#安装依赖的命令" class="headerlink" title="安装依赖的命令"></a>安装依赖的命令</h3><p><code>npm-install</code></p>
<p><code>npm-i</code></p>
<h3 id="删除依赖的命令"><a href="#删除依赖的命令" class="headerlink" title="删除依赖的命令"></a>删除依赖的命令</h3><p><code>npm-unisntall</code></p>
<p><code>npm-un</code></p>
<p><code>npm-remove</code></p>
<p><code>npm-rm</code></p>
<p><code>npm-r</code></p>
<h3 id="手工生成-shrinkwrap-描述"><a href="#手工生成-shrinkwrap-描述" class="headerlink" title="手工生成 shrinkwrap 描述"></a>手工生成 shrinkwrap 描述</h3><p><code>npm-shrinkwrap</code></p>
<h2 id="在开发中使用-npm-install"><a href="#在开发中使用-npm-install" class="headerlink" title="在开发中使用 npm-install"></a>在开发中使用 npm-install</h2><h3 id="引入新依赖包"><a href="#引入新依赖包" class="headerlink" title="引入新依赖包"></a>引入新依赖包</h3><ol>
<li>npm-install PACKAGE_NAME@VERSION –save 获取特定版本的包</li>
<li>测试功能</li>
<li>在代码仓库中提交 shrinkwrap / package.json 描述</li>
</ol>
<p>npm-install 在运行时会对 package.json 中的依赖做校验，如果你直接修改 package.json 文件，或者是指定了一个非严格的版本号，在运行的时候都会做更新检查，防止遗漏。</p>
<p>值得注意的是，因为 npm-install 会进行依赖对比和校验，在安装新包的时候需要带上 –save 参数。否则，在自动更新 shrinkwrap 描述之前，脚本会自动移除多余的依赖包，导致你新安装的包被删除。</p>
<h3 id="升级依赖包"><a href="#升级依赖包" class="headerlink" title="升级依赖包"></a>升级依赖包</h3><ol>
<li>npm outdated 获取项目所有依赖的更新信息</li>
<li>npm-install PACKAGE_NAME@VERSION –save 获取特定版本的包</li>
<li>测试功能</li>
<li>在代码仓库中提交 shrinkwrap / package.json 描述  </li>
</ol>
<p>package.json 文件中指定了一个非严格的版本号的依赖在运行 npm-install 的时候会做自动更新检查，无需指定版本号，如果你不希望进行自动更新，请在 package.json 中使用严格版本号。</p>
<h3 id="删除依赖包"><a href="#删除依赖包" class="headerlink" title="删除依赖包"></a>删除依赖包</h3><ol>
<li>npm-uninstall PACKAGE_NAME –save 删除这个包</li>
<li>测试功能</li>
<li>在代码仓库中提交 shrinkwrap / package.json 描述</li>
<li>可以看到，在实际使用中没有引入额外的流程，对开发者基本没有学习的负担。但仍然注意，不建议开发者执行 npm update 命令更新所有的依赖。</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过引入 shrinkwrap 文件，我们可以较好的管理项目的依赖关系，让上线变得更轻松。需要注意的是，尽管相关工具可以帮助你减化工作流程、可靠的分发依赖描述，但工具不能取代功能测试；每次升级依赖版本之后，我们仍然应该进行相关测试来确保项目能可靠的运行在该环境中。</p>
<p>如果使用 <a href="https://www.npmjs.com/package/@th507/npm-shrinkwrap" target="_blank" rel="external">@th507/npm-shrinkwrap</a> 或者 <a href="https://github.com/th507/npm-shrinkwrap-install" target="_blank" rel="external">npm-shrinkwrap-install </a>有任何问题欢迎给我提 issue。</p>
<p>本文没有涉及如何优化上线前的安装过程，缩短依赖构建时间，这个问题留给专门的文介绍。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文转自美团技术博客，原文：<a href="http://tech.meituan.com/npm-shrinkwrap.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="exter]]>
    </summary>
    
      <category term="nodejs" scheme="http://www.zoucz.com/blog/tags/nodejs/"/>
    
      <category term="npm" scheme="http://www.zoucz.com/blog/tags/npm/"/>
    
      <category term="nodejs" scheme="http://www.zoucz.com/blog/categories/nodejs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[理解nodejs模块的scope]]></title>
    <link href="http://www.zoucz.com/blog/2016/02/18/npm-scope/"/>
    <id>http://www.zoucz.com/blog/2016/02/18/npm-scope/</id>
    <published>2016-02-18T03:01:13.000Z</published>
    <updated>2016-12-21T16:42:00.000Z</updated>
    <content type="html"><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>原文档地址：<a href="https://docs.npmjs.com/misc/scope" target="_blank" rel="external">https://docs.npmjs.com/misc/scope</a>  </p>
<p>所有npm模块都有name，有的模块的name还有scope。scope的命名规则和name差不多，同样不能有url非法字符或者下划线点符号开头。scope在模块name中使用时，以@开头，后边跟一个/ 。package.json中，name的写法如下：  </p>
<blockquote>
<p>@somescope/somepackagename</p>
</blockquote>
<p>scope是一种把相关的模块组织到一起的一种方式，也会在某些地方影响npm对模块的处理。  </p>
<p>npm公共仓库支持带有scope的的模块，同时npm客户端对没有scope的模块也是向后兼容的，所以可以同时使用两者。  </p>
<h1 id="安装带有scope的模块"><a href="#安装带有scope的模块" class="headerlink" title="安装带有scope的模块"></a>安装带有scope的模块</h1><p>带有scope的模块安装在一个子目录中，如果正常的模块安装在node_modules/packagename目录下，那么带有scope的模块安装在node_modules/@myorg/packagename目录下，@myorg就是scope前面加上了@符号，一个scope中可以包含很多个模块。  </p>
<p>安装一个带有scope的模块：  </p>
<blockquote>
<p>npm install @myorg/mypackage</p>
</blockquote>
<p>在package.json中写明一个依赖:  </p>
<blockquote>
<p>“dependencies”: {<br>  “@myorg/mypackage”: “^1.3.0”<br>}</p>
</blockquote>
<p>如果@符号被省略，那么npm会尝试从github中安装模块，在npm install命令的文档中有说明  <a href="https://docs.npmjs.com/cli/install" target="_blank" rel="external">https://docs.npmjs.com/cli/install</a>  </p>
<h1 id="require带有scope的模块"><a href="#require带有scope的模块" class="headerlink" title="require带有scope的模块"></a>require带有scope的模块</h1><p>在代码中require一个含有scope的模块：  </p>
<blockquote>
<p>require(‘@myorg/mypackage’)</p>
</blockquote>
<p>nodejs在解析socpe模块的时候，并没有把它当做一个有什么蹊跷的东西来处理，仅仅是按照路径去找@myorg目录下的mypackage模块。  </p>
<h1 id="发布带有scope的模块"><a href="#发布带有scope的模块" class="headerlink" title="发布带有scope的模块"></a>发布带有scope的模块</h1><p>带有scope的模块可以被发布到任意支持socpe模块的npm仓库，包括npm公共仓库，公共仓库从2015-04-19就开始支持带有scope的模块了。 </p>
<p>如果有必要，可以把某个scope关联到某个仓库，见下面的说明。  </p>
<p>如果要发布一个公共socpe模块，你必须在最开始发布的时候指定–access public。这样会让模块能被公开使用，就像在publish之后运行了 npm access public命令一样。  </p>
<p>如果要发布私有模块，那么你必须有一个npm私有模块账户，可以选择自己搭建一个npm服务，或者直接使用官方的，官方的需要支付7刀/月。  </p>
<p>发布私有模块的命令：  </p>
<blockquote>
<p>npm publish </p>
</blockquote>
<p>或者</p>
<blockquote>
<p>npm publish –access restricted 。</p>
</blockquote>
<p>即发布socpe模块时，默认就是restricted的。<br>这些在npm publish文档里边可以看到详细说明。 <a href="https://docs.npmjs.com/cli/publish" target="_blank" rel="external">https://docs.npmjs.com/cli/publish </a></p>
<h1 id="将一个scope和一个仓库关联"><a href="#将一个scope和一个仓库关联" class="headerlink" title="将一个scope和一个仓库关联"></a>将一个scope和一个仓库关联</h1><p>scope可以和一些自己搞的npm仓库关联起来。这样你就可以同时使用npm公共仓库和一些其他的私有仓库中的模块，例如企业npm。<br>可以用npm login把scope关联到一个仓库：  </p>
<blockquote>
<p>npm login –registry=<a href="http://reg.example.com" target="_blank" rel="external">http://reg.example.com</a> –scope=@myco   </p>
</blockquote>
<p>scope和仓库可以是一个多对一的关系：一个仓库里边可以放多个scope，但是一个scope同时只能放在一个仓库中。<br>也可以用npm config把scope关联到一个仓库：  </p>
<blockquote>
<p>npm config set @myco:registry <a href="http://reg.example.com" target="_blank" rel="external">http://reg.example.com</a></p>
</blockquote>
<p>当一个scope关联到一个私有仓库之后，该scope下的模块在npm install的时候都会从它关联的仓库中获取模块，而不是npm配置的仓库，发布的时候也是同样的道理，会发布到它关联的仓库而不是npm配置的仓库。  </p>
<h1 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h1><ul>
<li><a href="https://docs.npmjs.com/cli/install" target="_blank" rel="external">npm-install</a>    </li>
<li><a href="https://docs.npmjs.com/cli/publish" target="_blank" rel="external">npm-publish</a>    </li>
<li><a href="https://docs.npmjs.com/cli/access" target="_blank" rel="external">npm-access</a>  </li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>原文档地址：<a href="https://docs.npmjs.com/misc/scope" target="_blank" rel=]]>
    </summary>
    
      <category term="nodejs" scheme="http://www.zoucz.com/blog/tags/nodejs/"/>
    
      <category term="npm" scheme="http://www.zoucz.com/blog/tags/npm/"/>
    
      <category term="npm-scope" scheme="http://www.zoucz.com/blog/tags/npm-scope/"/>
    
      <category term="nodejs" scheme="http://www.zoucz.com/blog/categories/nodejs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[nodejs模块发布及命令行程序开发]]></title>
    <link href="http://www.zoucz.com/blog/2016/02/17/node-cmd-app/"/>
    <id>http://www.zoucz.com/blog/2016/02/17/node-cmd-app/</id>
    <published>2016-02-17T10:01:17.000Z</published>
    <updated>2016-12-21T16:42:00.000Z</updated>
    <content type="html"><![CDATA[<h1 id="前置技能"><a href="#前置技能" class="headerlink" title="前置技能"></a>前置技能</h1><ul>
<li>npm工具为nodejs提供了一个模块和管理程序模块依赖的机制，当我们希望把模块贡献出去给他人使用时，可以把我们的程序发布到npm提供的公共仓库中，为了方便模块的管理，npm规定要使用一个叫package.json的文件来描述我们模块的名称、版本等信息。    </li>
<li>我们贡献出去的程序模块，可能也依赖了别人所编写的模块，所以需要在package.json中写明我们依赖了哪些模块，便于别人安装。    </li>
<li>简单的nodejs程序可以通过 node xxx.js 来运行，当我们希望直接在控制台中使用xxx命令运行nodejs程序时，需要创建一个cmd命令文件(windows下)，并把它放到path路径下，npm提供了一个自动完成这个工作的流程，这个也是在package.json里边配置的。</li>
</ul>
<p>基于以上几点，我觉得有必要挨个理解一下package.json里边的配置项：<a href="http://zoucz.com/blog/2016/02/17/npm-package" target="_blank" rel="external">我理解翻译的package.json文档</a>    </p>
<h1 id="模块发布"><a href="#模块发布" class="headerlink" title="模块发布"></a>模块发布</h1><p>发布一个npm模块非常简单。</p>
<h2 id="注册npm账户"><a href="#注册npm账户" class="headerlink" title="注册npm账户"></a>注册npm账户</h2><p>这个账户注册体验多好啊，不过记得密码别搞忘记了。<br>npm adduser<br>Username: zoucz<br>Password: ******<br>Email: 405966530@qq.com   </p>
<h2 id="创建一个测试模块"><a href="#创建一个测试模块" class="headerlink" title="创建一个测试模块"></a>创建一个测试模块</h2><p>新建一个文件夹，npm init，一路enter ，要注意的是name不能是已经被别人抢占的，可以到<a href="http://npmjs.org" target="_blank" rel="external">http://npmjs.org</a>这里查询。<br>此时文件夹下会生成一个package.json文件，如果看过package.json里边配置的含义，这里就比较好理解了。<br>新建一个index.js，内容如下：<br><img src="http://zoucz.com/blogimgs/2016-02-17/1455699748299.png" alt=""><br>此时模块就创建完毕了，简单吧！    </p>
<h2 id="发布模块"><a href="#发布模块" class="headerlink" title="发布模块"></a>发布模块</h2><p>在刚刚新建的文件夹下打开cmd，运行npm publish ，模块发布完毕！<br>要注意的是每次发布的时候都需要增加版本号。<br>此时在<a href="http://npmjs.org" target="_blank" rel="external">http://npmjs.org</a>这里就可以查询到刚刚发布的模块了，我测试模块名称是zoucz，那么此时别人也可以通过 npm install zoucz来使用我发布的模块了。    </p>
<h1 id="开发控制台命令程序"><a href="#开发控制台命令程序" class="headerlink" title="开发控制台命令程序"></a>开发控制台命令程序</h1><p>以windows下为例，我们怎么样才能创建一个cmd命令呢？  </p>
<p>1.在环境变量里边添加一段：”;D:/test”  </p>
<p>2.在d盘test目录下创建一个mycmd.cmd文件  </p>
<p>这时就可以使用mycmd命令了。那么要怎么在cmd中调用node程序呢？ 很简单：  </p>
<p>3.在那个mycmd.cmd文件里边写上  node path/to/xxx.js，就可以了。 </p>
<p>使用npm创建控制台命令程序，我们不需要自己完成上面的步骤，只需要增加一行配置就可以了  </p>
<h2 id="添加要执行的nodejs代码文件"><a href="#添加要执行的nodejs代码文件" class="headerlink" title="添加要执行的nodejs代码文件"></a>添加要执行的nodejs代码文件</h2><p>在模块根目录下添加bin目录<br><img src="http://zoucz.com/blogimgs/2016-02-17/1455701588490.png" alt=""><br>新建zoucz.js内容如下：   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/usr/bin/env node</span></div><div class="line"><span class="keyword">var</span> util=<span class="built_in">require</span>(<span class="string">"util"</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"hello,i'm zouchegnzhuo,you can type command name/site/email"</span>);</div><div class="line"><span class="keyword">var</span> cmd=process.argv[<span class="number">2</span>];</div><div class="line"><span class="keyword">if</span>(cmd)&#123;</div><div class="line">    <span class="keyword">switch</span>(cmd)&#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">"name"</span>:</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"邹成卓"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">"site"</span>:</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"http://zoucz.com"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">"email"</span>:</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"405966530@qq.com"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要注意的是，文件首行的 <strong><span style="color:red">#!/usr/bin/env node</span></strong> 一定要添加 ，这一行的意思是生成cmd文件的时候用什么路径的什么程序来运行上面的代码，文章末尾的demo中给出了不加的后果。    </p>
<h2 id="在package-json中配置bin"><a href="#在package-json中配置bin" class="headerlink" title="在package.json中配置bin"></a>在package.json中配置bin</h2><p>在package.json中配置<br><img src="http://zoucz.com/blogimgs/2016-02-17/1455701982810.png" alt=""><br>模块在npm install的时候会生成zoucz和zoucz_err两个cmd文件。    </p>
<h2 id="发布模块-1"><a href="#发布模块-1" class="headerlink" title="发布模块"></a>发布模块</h2><p>添加好上面的配置后，发布模块，别的码农就可以安装使用此命令了。   </p>
<h2 id="安装使用控制台命令程序"><a href="#安装使用控制台命令程序" class="headerlink" title="安装使用控制台命令程序"></a>安装使用控制台命令程序</h2><p>在cmd中 npm install -g zoucz ，就可以安装上面的模块，安装完成后可以使用zoucz命令和zoucz_err命令。<br><img src="http://zoucz.com/blogimgs/2016-02-17/1455702296719.png" alt="">   </p>
<p>zoucz_err是没有在js文件首行写#!/usr/bin/env node的后果：<br><img src="http://zoucz.com/blogimgs/2016-02-17/1455702357644.png" alt=""><br>运行命令之后：<br><img src="http://zoucz.com/blogimgs/2016-02-17/1455702374632.png" alt="">    </p>
<p>我们顺着图片中的路径，在C:\Users\czzou\AppData\Roaming\npm目录下可以找到npm为我们创建的cmd文件路径：<br><img src="http://zoucz.com/blogimgs/2016-02-17/1455702446611.png" alt=""><br>可以看到npm创建cmd文件的同时也创建了linux下使用的文件。<br>现在来看一下为什么执行zoucz_err会报错，分别打开两个cmd文件：<br>zoucz.cmd<br><img src="http://zoucz.com/blogimgs/2016-02-17/1455702842735.png" alt=""><br>zoucz_err.cmd<br><img src="http://zoucz.com/blogimgs/2016-02-17/1455702869691.png" alt=""><br>后者压根就没有用node去执行那段代码，当然会报错了~<br>这里要注意的是npm install -g  全局安装的时候，cmd文件是被创建在上面的路径下的，如果没有-g选项，局部安装，则会被创建在项目根目录node_modules/.bin 目录下。    </p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>npm可以帮我们做很多事情，做node开发的同学们都有必要花时间慢慢把npm的文档啃完<a href="https://docs.npmjs.com" target="_blank" rel="external">https://docs.npmjs.com</a><br>本文所使用的demo地址：<a href="https://github.com/zouchengzhuo/nodejsLearn/tree/master/zoucz" target="_blank" rel="external">https://github.com/zouchengzhuo/nodejsLearn/tree/master/zoucz</a>       </p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="前置技能"><a href="#前置技能" class="headerlink" title="前置技能"></a>前置技能</h1><ul>
<li>npm工具为nodejs提供了一个模块和管理程序模块依赖的机制，当我们希望把模块贡献出去给他人使用时，可以把我们]]>
    </summary>
    
      <category term="nodejs" scheme="http://www.zoucz.com/blog/tags/nodejs/"/>
    
      <category term="npm" scheme="http://www.zoucz.com/blog/tags/npm/"/>
    
      <category term="nodejs" scheme="http://www.zoucz.com/blog/categories/nodejs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[npm package.json属性详解]]></title>
    <link href="http://www.zoucz.com/blog/2016/02/17/npm-package/"/>
    <id>http://www.zoucz.com/blog/2016/02/17/npm-package/</id>
    <published>2016-02-17T01:28:04.000Z</published>
    <updated>2016-12-21T16:42:00.000Z</updated>
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文档的内容是package.json配置里边的属性含义。package.json必须是一个严格的json文件，而不仅仅是js里边的一个对象。其中很多属性可以通过npm-config来生成。   </p>
<h1 id="name"><a href="#name" class="headerlink" title="name"></a>name</h1><p>package.json中最重要的属性是name和version两个属性，这两个属性是必须要有的，否则模块就无法被安装，这两个属性一起形成了一个npm模块的唯一标识符。模块中内容变更的同时，模块版本也应该一起变化。<br>name属性就是你的模块名称，下面是一些命名规则:<br>name必须小于等于214个字节，包括前缀名称在内（如 xxx/xxxmodule）。    </p>
<ul>
<li>name不能以”_”或”.”开头    </li>
<li>不能含有大写字母    </li>
<li>name会成为url的一部分，不能含有url非法字符   </li>
</ul>
<p>下面是官网文档的一些建议：   </p>
<ul>
<li>不要使用和node核心模块一样的名称     </li>
<li>name中不要含有”js”和”node”。 It’s assumed that it’s js, since you’re writing a package.json file, and you can specify the engine using the “engines” field. (See below.) </li>
<li>name属性会成为模块url、命令行中的一个参数或者一个文件夹名称，任何非url安全的字符在name中都不能使用，也不能以”_”或”.”开头 </li>
<li>name属性也许会被写在require()的参数中，所以最好取个简短而语义化的值。</li>
<li>创建一个模块前可以先到后边的网址查查name是否已经被占用. <a href="https://www.npmjs.com/" target="_blank" rel="external">https://www.npmjs.com/</a>    </li>
</ul>
<p>name属性可以有一些前缀如 e.g. @myorg/mypackage.在npm-scope(7)的文档中可以看到详细说明    </p>
<h1 id="version"><a href="#version" class="headerlink" title="version"></a>version</h1><p>version必须可以被npm依赖的一个node-semver模块解析。具体规则见下面的dependencies模块    </p>
<h1 id="description"><a href="#description" class="headerlink" title="description"></a>description</h1><p>一个描述，方便别人了解你的模块作用，搜索的时候也有用。    </p>
<h1 id="keywords"><a href="#keywords" class="headerlink" title="keywords"></a>keywords</h1><p>一个字符串数组，方便别人搜索到本模块    </p>
<h1 id="homepage"><a href="#homepage" class="headerlink" title="homepage"></a>homepage</h1><p>项目主页url<br><strong>注意:</strong> 这个项目主页url和url属性不同，如果你填写了url属性，npm注册工具会认为你把项目发布到其他地方了，获取模块的时候不会从npm官方仓库获取，而是会重定向到url属性配置的地址。<br>（原文档中用了 spit(吐)这个单词，作者表示他不是在开玩笑:）    </p>
<h1 id="bugs"><a href="#bugs" class="headerlink" title="bugs"></a>bugs</h1><p>填写一个bug提交地址或者一个邮箱，被你的模块坑到的人可以通过这里吐槽，例如：    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123; &quot;url&quot; : &quot;https://github.com/owner/project/issues&quot;</div><div class="line">, &quot;email&quot; : &quot;project@hostname.com&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>url和email可以任意填或不填，如果只填一个，可以直接写成一个字符串而不是对象。如果填写了url，npm bugs命令会使用这个url。    </p>
<h1 id="license"><a href="#license" class="headerlink" title="license"></a>license</h1><p>你应该为你的模块制定一个协议，让用户知道他们有何权限来使用你的模块，以及使用该模块有哪些限制。最简单的，例如你用BSD-3-Clause 或 MIT之类的协议，如下：<br>{ “license” : “BSD-3-Clause” }<br>你可以在<a href="https://spdx.org/licenses/" target="_blank" rel="external">https://spdx.org/licenses/ </a>这个地址查阅协议列表 。    </p>
<h1 id="和用户相关的属性-author-contributors"><a href="#和用户相关的属性-author-contributors" class="headerlink" title="和用户相关的属性: author, contributors"></a>和用户相关的属性: author, contributors</h1><p>“author”是一个码农， “contributors”是一个码农数组。 “person”是一个有一些描述属性的对象，如下 like this:   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123; &quot;name&quot; : &quot;Barney Rubble&quot;</div><div class="line">, &quot;email&quot; : &quot;b@rubble.com&quot;</div><div class="line">, &quot;url&quot; : &quot;http://barnyrubble.tumblr.com/&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也可以按如下格式缩写，npm会帮着转换:<br>“Barney Rubble <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#98;&#64;&#114;&#x75;&#98;&#98;&#x6c;&#x65;&#x2e;&#x63;&#111;&#109;">&#98;&#64;&#114;&#x75;&#98;&#98;&#x6c;&#x65;&#x2e;&#x63;&#111;&#109;</a> (<a href="http://barnyrubble.tumblr.com/" target="_blank" rel="external">http://barnyrubble.tumblr.com/</a>)”<br>email和url属性实际上都是可以省略的。描述用户信息的还有一个”maintainers”（维护者）属性。   </p>
<h1 id="files"><a href="#files" class="headerlink" title="files"></a>files</h1><p>“files”属性的值是一个数组，内容是模块下文件名或者文件夹名，如果是文件夹名，则文件夹下所有的文件也会被包含进来（除非文件被另一些配置排除了）<br>你也可以在模块根目录下创建一个”.npmignore”文件（windows下无法直接创建以”.”开头的文件，使用linux命令行工具创建如git bash），写在这个文件里边的文件即便被写在files属性里边也会被排除在外，这个文件的写法”.gitignore”类似。 </p>
<h1 id="main"><a href="#main" class="headerlink" title="main"></a>main</h1><p>main属性指定了程序的主入口文件。意思是，如果你的模块被命名为foo，用户安装了这个模块并通过require(“foo”)来使用这个模块，那么require返回的内容就是main属性指定的文件中 module.exports指向的对象。<br>它应该指向模块根目录下的一个文件。对大对数模块而言，这个属性更多的是让模块有一个主入口文件，然而很多模块并不写这个属性。   </p>
<h1 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h1><p>很多模块有一个或多个需要配置到PATH路径下的可执行模块，npm让这个工作变得十分简单（实际上npm本身也是通过bin属性安装为一个可执行命令的）<br>如果要用npm的这个功能，在package.json里边配置一个bin属性。bin属性是一个已命令名称为key，本地文件名称为value的map如下：   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; &quot;bin&quot; : &#123; &quot;myapp&quot; : &quot;./cli.js&quot; &#125; &#125;</div></pre></td></tr></table></figure>
<p>模块安装的时候，若是全局安装，则npm会为bin中配置的文件在bin目录下创建一个软连接（对于windows系统，默认会在C:\Users\username\AppData\Roaming\npm目录下），若是局部安装，则会在项目内的./node_modules/.bin/目录下创建一个软链接。<br>因此，按上面的例子，当你安装myapp的时候，npm就会为cli.js在/usr/local/bin/myapp路径创建一个软链接。<br>如果你的模块只有一个可执行文件，并且它的命令名称和模块名称一样，你可以只写一个字符串来代替上面那种配置，例如：    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123; &quot;name&quot;: &quot;my-program&quot;</div><div class="line">, &quot;version&quot;: &quot;1.2.5&quot;</div><div class="line">, &quot;bin&quot;: &quot;./path/to/program&quot; &#125;</div></pre></td></tr></table></figure>
<p>作用和如下写法相同:   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123; &quot;name&quot;: &quot;my-program&quot;</div><div class="line">, &quot;version&quot;: &quot;1.2.5&quot;</div><div class="line">, &quot;bin&quot; : &#123; &quot;my-program&quot; : &quot;./path/to/program&quot; &#125; &#125;</div></pre></td></tr></table></figure>
<h1 id="man"><a href="#man" class="headerlink" title="man"></a>man</h1><p>制定一个或通过数组制定一些文件来让linux下的man命令查找文档地址。<br>如果只有一个文件被指定的话，安装后直接使用man+模块名称，而不管man指定的文件的实际名称。例如:   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123; &quot;name&quot; : &quot;foo&quot;</div><div class="line">, &quot;version&quot; : &quot;1.2.3&quot;</div><div class="line">, &quot;description&quot; : &quot;A packaged foo fooer for fooing foos&quot;</div><div class="line">, &quot;main&quot; : &quot;foo.js&quot;</div><div class="line">, &quot;man&quot; : &quot;./man/doc.1&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过man foo命令会得到 ./man/doc.1 文件的内容。<br>如果man文件名称不是以模块名称开头的，安装的时候会给加上模块名称前缀。因此，下面这段配置：   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123; &quot;name&quot; : &quot;foo&quot;</div><div class="line">, &quot;version&quot; : &quot;1.2.3&quot;</div><div class="line">, &quot;description&quot; : &quot;A packaged foo fooer for fooing foos&quot;</div><div class="line">, &quot;main&quot; : &quot;foo.js&quot;</div><div class="line">, &quot;man&quot; : [ &quot;./man/foo.1&quot;, &quot;./man/bar.1&quot; ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>会创建一些文件来作为man foo和man foo-bar命令的结果。<br>man文件必须以数字结尾，或者如果被压缩了，以.gz结尾。数字表示文件将被安装到man的哪个部分。   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123; &quot;name&quot; : &quot;foo&quot;</div><div class="line">, &quot;version&quot; : &quot;1.2.3&quot;</div><div class="line">, &quot;description&quot; : &quot;A packaged foo fooer for fooing foos&quot;</div><div class="line">, &quot;main&quot; : &quot;foo.js&quot;</div><div class="line">, &quot;man&quot; : [ &quot;./man/foo.1&quot;, &quot;./man/foo.2&quot; ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>会创建 man foo 和 man 2 foo 两条命令。   </p>
<h1 id="directories"><a href="#directories" class="headerlink" title="directories"></a>directories</h1><p>CommonJs通过directories来制定一些方法来描述模块的结构，看看npm的package.json文件<a href="https://registry.npmjs.org/npm/latest" target="_blank" rel="external">https://registry.npmjs.org/npm/latest</a> ，可以发现里边有这个字段的内容。<br><img src="http://zoucz.com/blogimgs/2016-02-16/1455624810992.png" alt=""><br>目前这个配置没有任何作用，将来可能会整出一些花样来。   </p>
<h2 id="directories-lib"><a href="#directories-lib" class="headerlink" title="directories.lib"></a>directories.lib</h2><p>告诉用户模块中lib目录在哪，这个配置目前没有任何作用，但是对使用模块的人来说是一个很有用的信息。    </p>
<h2 id="directories-bin"><a href="#directories-bin" class="headerlink" title="directories.bin"></a>directories.bin</h2><p>如果你在这里指定了bin目录，这个配置下面的文件会被加入到bin路径下，如果你已经在package.json中配置了bin目录，那么这里的配置将不起任何作用。  </p>
<h2 id="directories-man"><a href="#directories-man" class="headerlink" title="directories.man"></a>directories.man</h2><p>指定一个目录，目录里边都是man文件，这是一种配置man文件的语法糖。   </p>
<h2 id="directories-doc"><a href="#directories-doc" class="headerlink" title="directories.doc"></a>directories.doc</h2><p>在这个目录里边放一些markdown文件，可能最终有一天它们会被友好的展现出来（应该是在npm的网站上）   </p>
<h2 id="directories-example"><a href="#directories-example" class="headerlink" title="directories.example"></a>directories.example</h2><p>放一些示例脚本，或许某一天会有用 - -！   </p>
<h1 id="repository"><a href="#repository" class="headerlink" title="repository"></a>repository</h1><p>指定一个代码存放地址，对想要为你的项目贡献代码的人有帮助。像这样：   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&quot;repository&quot; :</div><div class="line">  &#123; &quot;type&quot; : &quot;git&quot;</div><div class="line">  , &quot;url&quot; : &quot;https://github.com/npm/npm.git&quot;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&quot;repository&quot; :</div><div class="line">  &#123; &quot;type&quot; : &quot;svn&quot;</div><div class="line">  , &quot;url&quot; : &quot;https://v8.googlecode.com/svn/trunk/&quot;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>若你的模块放在GitHub, GitHub gist, Bitbucket, or GitLab的仓库里，npm install的时候可以使用缩写标记来完成：    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&quot;repository&quot;: &quot;npm/npm&quot;</div><div class="line"></div><div class="line">&quot;repository&quot;: &quot;gist:11081aaa281&quot;</div><div class="line"></div><div class="line">&quot;repository&quot;: &quot;bitbucket:example/repo&quot;</div><div class="line"></div><div class="line">&quot;repository&quot;: &quot;gitlab:another/repo&quot;</div></pre></td></tr></table></figure>
<h1 id="scripts"><a href="#scripts" class="headerlink" title="scripts"></a>scripts</h1><p>scripts属性是一个对象，里边指定了项目的生命周期个各个环节需要执行的命令。key是生命周期中的事件，value是要执行的命令。<br>具体的内容有 install  start  stop 等，详见<a href="https://docs.npmjs.com/misc/scripts" target="_blank" rel="external"> https://docs.npmjs.com/misc/scripts</a>     </p>
<h1 id="config"><a href="#config" class="headerlink" title="config"></a>config</h1><p>用来设置一些项目不怎么变化的项目配置，例如port等。<br>用户用的时候可以使用如下用法：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http.createServer(...).listen(process.env.npm_package_config_port)</div></pre></td></tr></table></figure>
<p>可以通过npm config set foo:port 80来修改config。详见<a href="https://docs.npmjs.com/misc/config" target="_blank" rel="external">https://docs.npmjs.com/misc/config</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123; &quot;name&quot; : &quot;foo&quot;</div><div class="line">, &quot;config&quot; : &#123; &quot;port&quot; : &quot;8080&quot; &#125; &#125;</div></pre></td></tr></table></figure>
<h1 id="dependencies"><a href="#dependencies" class="headerlink" title="dependencies"></a>dependencies</h1><p>dependencies属性是一个对象，配置模块依赖的模块列表，key是模块名称，value是版本范围，版本范围是一个字符，可以被一个或多个空格分割。<br>dependencies也可以被指定为一个git地址或者一个压缩包地址。<br>不要把测试工具或transpilers写到dependencies中。 下面是一些写法，详见<a href="https://docs.npmjs.com/misc/semver" target="_blank" rel="external">https://docs.npmjs.com/misc/semver </a>    </p>
<ul>
<li>version 精确匹配版本   </li>
<li>>version 必须大于某个版本   </li>
<li>>=version 大于等于   </li>
<li>&lt;version 小于      </li>
<li>&lt;=versionversion 小于     </li>
<li>~version “约等于”，具体规则详见semver文档   </li>
<li>^version “兼容版本”具体规则详见semver文档   </li>
<li>1.2.x 仅一点二点几的版本   </li>
<li>http://… 见下面url作为denpendencies的说明   </li>
<li><ul>
<li>任何版本   </li>
</ul>
</li>
<li>“”  空字符，和*相同   </li>
<li>version1 - version2 相当于 &gt;=version1 &lt;=version2.   </li>
<li>range1 || range2  范围1和范围2满足任意一个都行   </li>
<li>git…  见下面git url作为denpendencies的说明   </li>
<li>user/repo See  见下面GitHub仓库的说明   </li>
<li>tag  发布的一个特殊的标签，见npm-tag的文档 <a href="https://docs.npmjs.com/getting-started/using-tags" target="_blank" rel="external">https://docs.npmjs.com/getting-started/using-tags</a>   </li>
<li>path/path/path  见下面本地模块的说明<br>下面的写法都是可以的:   </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&#123; &quot;dependencies&quot; :</div><div class="line">  &#123; &quot;foo&quot; : &quot;1.0.0 - 2.9999.9999&quot;</div><div class="line">  , &quot;bar&quot; : &quot;&gt;=1.0.2 &lt;2.1.2&quot;</div><div class="line">  , &quot;baz&quot; : &quot;&gt;1.0.2 &lt;=2.3.4&quot;</div><div class="line">  , &quot;boo&quot; : &quot;2.0.1&quot;</div><div class="line">  , &quot;qux&quot; : &quot;&lt;1.0.0 || &gt;=2.3.1 &lt;2.4.5 || &gt;=2.5.2 &lt;3.0.0&quot;</div><div class="line">  , &quot;asd&quot; : &quot;http://asdf.com/asdf.tar.gz&quot;</div><div class="line">  , &quot;til&quot; : &quot;~1.2&quot;</div><div class="line">  , &quot;elf&quot; : &quot;~1.2.3&quot;</div><div class="line">  , &quot;two&quot; : &quot;2.x&quot;</div><div class="line">  , &quot;thr&quot; : &quot;3.3.x&quot;</div><div class="line">  , &quot;lat&quot; : &quot;latest&quot;</div><div class="line">  , &quot;dyl&quot; : &quot;file:../dyl&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="URLs-as-Dependencies"><a href="#URLs-as-Dependencies" class="headerlink" title="URLs as Dependencies"></a>URLs as Dependencies</h1><p>在版本范围的地方可以写一个url指向一个压缩包，模块安装的时候会把这个压缩包下载下来安装到模块本地。   </p>
<h1 id="Git-URLs-as-Dependencies"><a href="#Git-URLs-as-Dependencies" class="headerlink" title="Git URLs as Dependencies"></a>Git URLs as Dependencies</h1><p>Git url可以像下面一样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git://github.com/user/project.git#commit-ish</div><div class="line">git+ssh://user@hostname:project.git#commit-ish</div><div class="line">git+ssh://user@hostname/project.git#commit-ish</div><div class="line">git+http://user@hostname/project/blah.git#commit-ish</div><div class="line">git+https://user@hostname/project/blah.git#commit-ish</div></pre></td></tr></table></figure>
<p>commit-ish 可以是任意标签，哈希值，或者可以检出的分支，默认是master分支。   </p>
<h1 id="GitHub-URLs"><a href="#GitHub-URLs" class="headerlink" title="GitHub URLs"></a>GitHub URLs</h1><p>支持github的 username/modulename 的写法，#后边可以加后缀写明分支hash或标签：   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;foo&quot;,</div><div class="line">  &quot;version&quot;: &quot;0.0.0&quot;,</div><div class="line">  &quot;dependencies&quot;: &#123;</div><div class="line">    &quot;express&quot;: &quot;visionmedia/express&quot;,</div><div class="line">    &quot;mocha&quot;: &quot;visionmedia/mocha#4727d357ea&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Local-Paths"><a href="#Local-Paths" class="headerlink" title="Local Paths"></a>Local Paths</h1><p>npm2.0.0版本以上可以提供一个本地路径来安装一个本地的模块，通过npm install xxx –save 来安装，格式如下：   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">../foo/bar</div><div class="line">~/foo/bar</div><div class="line">./foo/bar</div><div class="line">/foo/bar</div></pre></td></tr></table></figure>
<p>package.json 生成的相对路径如下:   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;baz&quot;,</div><div class="line">  &quot;dependencies&quot;: &#123;</div><div class="line">    &quot;bar&quot;: &quot;file:../foo/bar&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种属性在离线开发或者测试需要用npm install的情况，又不想自己搞一个npm server的时候有用，但是发布模块到公共仓库时不应该使用这种属性。   </p>
<h1 id="devDependencies"><a href="#devDependencies" class="headerlink" title="devDependencies"></a>devDependencies</h1><p>如果有人想要下载并使用你的模块，也许他们并不希望或需要下载一些你在开发过程中使用的额外的测试或者文档框架。<br>在这种情况下，最好的方法是把这些依赖添加到devDependencies属性的对象中。<br>这些模块会在npm link或者npm install的时候被安装，也可以像其他npm配置一样被管理，详见npm的config文档。<br>对于一些跨平台的构建任务，例如把CoffeeScript编译成JavaScript，就可以通过在package.json的script属性里边配置prepublish脚本来完成这个任务，然后需要依赖的coffee-script模块就写在devDependencies属性种。<br>例如:   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123; &quot;name&quot;: &quot;ethopia-waza&quot;,</div><div class="line">  &quot;description&quot;: &quot;a delightfully fruity coffee varietal&quot;,</div><div class="line">  &quot;version&quot;: &quot;1.2.3&quot;,</div><div class="line">  &quot;devDependencies&quot;: &#123;</div><div class="line">    &quot;coffee-script&quot;: &quot;~1.6.3&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;scripts&quot;: &#123;</div><div class="line">    &quot;prepublish&quot;: &quot;coffee -o lib/ -c src/waza.coffee&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;main&quot;: &quot;lib/waza.js&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>prepublish脚本会在发布之前运行，因此用户在使用之前就不用再自己去完成编译的过程了。在开发模式下，运行npm install也会执行这个脚本（见npm script文档），因此可以很方便的调试。   </p>
<h1 id="peerDependencies"><a href="#peerDependencies" class="headerlink" title="peerDependencies"></a>peerDependencies</h1><p>有时候做一些插件开发，比如grunt等工具的插件，它们往往是在grunt的某个版本的基础上开发的，而在他们的代码中并不会出现require(“grunt”)这样的依赖，dependencies配置里边也不会写上grunt的依赖，为了说明此模块只能作为插件跑在宿主的某个版本范围下，可以配置peerDependencies：   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;tea-latte&quot;,</div><div class="line">  &quot;version&quot;: &quot;1.3.5&quot;,</div><div class="line">  &quot;peerDependencies&quot;: &#123;</div><div class="line">    &quot;tea&quot;: &quot;2.x&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这个配置确保再npm install的时候tea-latte会和2.x版本的tea一起安装，而且它们两个的依赖关系是同级的：<br>├── tea-latte@1.3.5<br>└── tea@2.2.0<br>这个配置的目的是让npm知道，如果要使用此插件模块，请确保安装了兼容版本的宿主模块。   </p>
<h1 id="bundledDependencies"><a href="#bundledDependencies" class="headerlink" title="bundledDependencies"></a>bundledDependencies</h1><p>上面的单词少个d，写成bundleDependencies也可以。<br>指定发布的时候会被一起打包的模块。   </p>
<h1 id="optionalDependencies"><a href="#optionalDependencies" class="headerlink" title="optionalDependencies"></a>optionalDependencies</h1><p>如果一个依赖模块可以被使用， 同时你也希望在该模块找不到或无法获取时npm继续运行，你可以把这个模块依赖放到optionalDependencies配置中。这个配置的写法和dependencies的写法一样，不同的是这里边写的模块安装失败不会导致npm install失败。<br>当然，这种模块就需要你自己在代码中处理模块确实的情况了，例如：   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">  var foo = require(&apos;foo&apos;)</div><div class="line">  var fooVersion = require(&apos;foo/package.json&apos;).version</div><div class="line">&#125; catch (er) &#123;</div><div class="line">  foo = null</div><div class="line">&#125;</div><div class="line">if ( notGoodFooVersion(fooVersion) ) &#123;</div><div class="line">  foo = null</div><div class="line">&#125;</div><div class="line"></div><div class="line">// .. then later in your program ..</div><div class="line"></div><div class="line">if (foo) &#123;</div><div class="line">  foo.doFooThings()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>optionalDependencies 中的配置会覆盖dependencies中的配置，最好只在一个地方写。   </p>
<h1 id="engines"><a href="#engines" class="headerlink" title="engines"></a>engines</h1><p>你可以指定项目运行的node版本范围，如下：<br>{ “engines” : { “node” : “&gt;=0.10.3 &lt;0.12” } }<br>和dependencies一样，如果你不指定版本范围或者指定为*，任何版本的node都可以。<br>也可以指定一些npm版本可以正确的安装你的模块，例如：<br>{ “engines” : { “npm” : “~1.0.20” } }<br>要注意的是，除非你设置了engine-strict属性，engines属性是仅供参考的。   </p>
<h1 id="engineStrict"><a href="#engineStrict" class="headerlink" title="engineStrict"></a>engineStrict</h1><p>注意：这个属性已经弃用，将在npm 3.0.0 版本干掉。   </p>
<h1 id="os"><a href="#os" class="headerlink" title="os"></a>os</h1><p>可以指定你的模块只能在哪个操作系统上跑：<br>“os” : [ “darwin”, “linux” ]<br>也可以指定黑名单而不是白名单：<br>“os” : [ “!win32” ]<br>服务的操作系统是由process.platform来判断的，这个属性允许黑白名单同时存在，虽然没啥必要这样搞…   </p>
<h1 id="cpu"><a href="#cpu" class="headerlink" title="cpu"></a>cpu</h1><p>限制模块只能在某某cpu架构下运行<br>“cpu” : [ “x64”, “ia32” ]<br>同样可以设置黑名单:<br>“cpu” : [ “!arm”, “!mips” ]<br>cpu架构通过 process.arch 判断   </p>
<h1 id="preferGlobal"><a href="#preferGlobal" class="headerlink" title="preferGlobal"></a>preferGlobal</h1><p>如果您的软件包主要用于安装到全局的命令行应用程序，那么该值设置为true ，如果它被安装在本地，则提供一个警告。实际上该配置并没有阻止用户把模块安装到本地，只是防止该模块被错误的使用引起一些问题。   </p>
<h1 id="private"><a href="#private" class="headerlink" title="private"></a>private</h1><p>如果这个属性被设置为true，npm将拒绝发布它，这是为了防止一个私有模块被无意间发布出去。如果你只想让模块被发布到一个特定的npm仓库，如一个内部的仓库，可与在下面的publishConfig中配置仓库参数。  </p>
<h1 id="publishConfig"><a href="#publishConfig" class="headerlink" title="publishConfig"></a>publishConfig</h1><p>这个配置是会在模块发布时用到的一些值的集合。如果你不想模块被默认被标记为最新的，或者默认发布到公共仓库，可以在这里配置tag或仓库地址。  </p>
<h1 id="DEFAULT-VALUES"><a href="#DEFAULT-VALUES" class="headerlink" title="DEFAULT VALUES"></a>DEFAULT VALUES</h1><p>npm设置了一些默认参数，如：<br>“scripts”: {“start”: “node server.js”}<br>如果模块根目录下有一个server.js文件，那么npm start会默认运行这个文件。<br>“scripts”:{“preinstall”: “node-gyp rebuild”}<br>如果模块根目录下有binding.gyp, npm将默认用node-gyp来编译preinstall的脚本<br>“contributors”: […]<br>若模块根目录下有AUTHORS 文件，则npm会按Name <email> (url)格式解析每一行的数据添加到contributors中，可以用#添加行注释   </email></p>
<h1 id="参考文档列表-https-docs-npmjs-com"><a href="#参考文档列表-https-docs-npmjs-com" class="headerlink" title="参考文档列表(https://docs.npmjs.com/)"></a>参考文档列表(<a href="https://docs.npmjs.com/" target="_blank" rel="external">https://docs.npmjs.com/</a>)</h1><p>semver(7)<br>npm-init(1)<br>npm-version(1)<br>npm-config(1)<br>npm-config(7)<br>npm-help(1)<br>npm-faq(7)<br>npm-install(1)<br>npm-publish(1)<br>npm-rm(1)   </p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文档的内容是package.json配置里边的属性含义。package.json必须是一个严格的json文件，而不仅仅是js里边的一个对象]]>
    </summary>
    
      <category term="nodejs" scheme="http://www.zoucz.com/blog/tags/nodejs/"/>
    
      <category term="npm" scheme="http://www.zoucz.com/blog/tags/npm/"/>
    
      <category term="nodejs" scheme="http://www.zoucz.com/blog/categories/nodejs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[nodejs process模块api]]></title>
    <link href="http://www.zoucz.com/blog/2016/02/05/node-process/"/>
    <id>http://www.zoucz.com/blog/2016/02/05/node-process/</id>
    <published>2016-02-05T08:26:37.000Z</published>
    <updated>2016-12-21T16:42:00.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>exit事件和beforeExit事件</li>
<li>exit事件提供一个退出状态码<br>###　进程退出状态码：</li>
<li>1 Uncaught Fatal Exception   因没有被捕获的异常而退出，这里的没有被捕获指的是没有被程序中代码和process的uncaughtException捕获</li>
<li>2 未使用 (reserved by Bash for builtin misuse)</li>
<li>3 Internal JavaScript Parse Error nodejs自身的javascript解析错误，这个很罕见，一般只在node自身项目开发过程中产生</li>
<li>4 Internal JavaScript Evaluation Failure nodejs自身错误，同3</li>
<li>5 Fatal Error  v8引擎致命错误</li>
<li>6 Non-function Internal Exception Handler 未捕获异常，nodejs内部的异常处理函数指向了一个非函数对象</li>
<li>7 Internal Exception Handler Run-Time Failure 内部异常处理器运行时错误，</li>
<li>如process.on(‘uncaughtException’) or domain.on(‘error’) 的回调里边发生错误</li>
<li>8 未使用 旧版本node偶尔用来表示未捕获异常</li>
<li>9 Invalid Argument  函数参数不合法</li>
<li>10 Internal JavaScript Run-Time Failure  nodejs的核心javascript文件运行错误，极少发生</li>
<li>12 Invalid Debug Argument   启动时使用了 –debug  或者–debug-brk 参数，却设置了错误的调试端口</li>
<li>大于128 Signal Exits 进程收到终止信号的时候，exit code是一个代表退出信号的大于128的数字，例如 SIGKILL 或者 SIGHUP  </li>
</ul>
<ul>
<li>Windows下node无法直接发送process信号，但是提供了方法process.kill()和child_process.kill()来模拟发送信号</li>
<li>发送信号 0 可以用来检测进程是否存在</li>
<li>发送信号 SIGTERM、SIGINT和SIGKILL 会无条件终止终端运行<h3 id="信号列表："><a href="#信号列表：" class="headerlink" title="信号列表："></a>信号列表：</h3></li>
<li>SIGUSR1  nodejs保留用于启动调试进程相关操作</li>
<li>SIGTERM和SIGINT   在非windows平台下，如果这两个信号被设置了监听，那么终端就不会exit，改为执行绑定的监听事件</li>
<li>在windows环境下10s后cmd会强行关闭，进程还是会退出</li>
<li>SIGPIPE  这个信号会被process忽略，用户可以绑定监听回调来执行一些操作</li>
<li>SIGHUP 1.windows平台下，此信号会在终端关闭时发出，可以监听此信号来处理一些逻辑，但是10s后终端会强行关闭</li>
<li>2.其他平台下，此信号的默认行为是关闭node终端，但是若给这个信号设置了监听函数，那么就会覆盖默认的关闭终端行为</li>
<li>SIGTERM  windows不支持，其他平台可以监听</li>
<li>SIGINT 全平台支持，一般在Ctrl+C时产生，但是在终端的raw mode下不产生</li>
<li>SIGBREAK 仅在windows上可被监听，Ctrl+Break时产生此信号，也是挺奇葩…  没有用过</li>
<li>SIGWINCH 终端尺寸改变时发出此信号</li>
<li>SIGKILL 无法被监听，所有平台上都是无条件关闭终端</li>
<li>SIGSTOP 无法被监听<br><em>
</em>/<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function t1()&#123;</div><div class="line">    process.on(&quot;exit&quot;,function(code)&#123;</div><div class="line">        setTimeout(function()&#123;</div><div class="line">            console.log(&quot;this will not run&quot;);</div><div class="line">        &#125;,0);</div><div class="line">        console.log(&quot;process exited!&quot;);</div><div class="line">    &#125;);</div><div class="line">    process.on(&quot;beforeExit&quot;,function()&#123;</div><div class="line">        console.log(&quot;process will exit!&quot;)</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>unhandledRejection事件和rejectionHandled事件</li>
<li>TODO create demo<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function t2()&#123;</div><div class="line">    var unhandledRejections = new Map();</div><div class="line">    process.on(&apos;unhandledRejection&apos;, function(reason, p) &#123;</div><div class="line">        console.log(&quot;promise rejected:&quot;,p,&quot;  reason:&quot;,reason);</div><div class="line">        unhandledRejections.set(p, reason);</div><div class="line">    &#125;);</div><div class="line">    process.on(&apos;rejectionHandled&apos;, function(p) &#123;</div><div class="line">        console.log(&quot;reject handled:&quot;,unhandledRejections.get(p));</div><div class="line">        unhandledRejections.delete(p);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>uncaughtException事件<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function t3()&#123;</div><div class="line">    process.on(&quot;uncaughtException&quot;,function(err)&#123;</div><div class="line">        console.log(&apos;Caught exception: &apos; + err);</div><div class="line">    &#125;)</div><div class="line">    setTimeout(function() &#123;</div><div class="line">        console.log(&apos;This will still run.&apos;);</div><div class="line">    &#125;, 5000);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>// Intentionally cause an exception, but don’t catch it.<br>    nonexistentFunc();<br>    console.log(‘This will not run.’);<br>}</p>
<p>/**</p>
<ul>
<li>arch 处理器类型 ‘arm’, ‘ia32’, or ‘x64’.</li>
<li>argv 获取程序的启动参数 0-node.exe路径 1- javascript文件名称，后边的是启动参数，可以用node index.js one two=three four 测试</li>
<li>execArgv 执行参数，例如 node –harmony index.js，这个属性里边的内容就是 –harmony，官方文档说用来生成子进程时采用相同的启动参数有用</li>
<li>cwd() 返回当前工作目录</li>
<li>chdir(dir) 更换进程工作目录</li>
<li>process.execPath 程序启动路径 D:\Program Files\nodejs\node.exe<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function t4()&#123;</div><div class="line">    console.log(&apos;This processor architecture is &apos; + process.arch);</div><div class="line">    // print process.argv</div><div class="line">    process.argv.forEach(function(val, index, array) &#123;</div><div class="line">        console.log(index + &apos;: &apos; + val);</div><div class="line">    &#125;);</div><div class="line">    console.log(&apos;Starting directory: &apos; + process.cwd());</div><div class="line">    try &#123;</div><div class="line">        process.chdir(&apos;../&apos;);</div><div class="line">        console.log(&apos;New directory: &apos; + process.cwd());</div><div class="line">    &#125;</div><div class="line">    catch (err) &#123;</div><div class="line">        console.log(&apos;chdir: &apos; + err);</div><div class="line">    &#125;</div><div class="line">    console.log(process.execPath);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>TODO process.config，这些属性代表什么？<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">function t5()&#123;</div><div class="line">    console.log(process.config);</div><div class="line">    //&#123; target_defaults:</div><div class="line">    //&#123; cflags: [],</div><div class="line">    //    default_configuration: &apos;Release&apos;,</div><div class="line">    //    defines: [],</div><div class="line">    //    include_dirs: [],</div><div class="line">    //    libraries: [] &#125;,</div><div class="line">    //    variables:</div><div class="line">    //    &#123; asan: 0,</div><div class="line">    //        host_arch: &apos;x64&apos;,</div><div class="line">    //        icu_data_file: &apos;icudt56l.dat&apos;,</div><div class="line">    //        icu_data_in: &apos;../../deps/icu/source/data/in\\icudt56l.dat&apos;,</div><div class="line">    //        icu_endianness: &apos;l&apos;,</div><div class="line">    //        icu_gyp_path: &apos;tools/icu/icu-generic.gyp&apos;,</div><div class="line">    //        icu_locales: &apos;en,root&apos;,</div><div class="line">    //        icu_path: &apos;deps\\icu&apos;,</div><div class="line">    //        icu_small: true,</div><div class="line">    //        icu_ver_major: &apos;56&apos;,</div><div class="line">    //        node_byteorder: &apos;little&apos;,</div><div class="line">    //        node_install_npm: true,</div><div class="line">    //        node_prefix: &apos;/usr/local&apos;,</div><div class="line">    //        node_release_urlbase: &apos;&apos;,</div><div class="line">    //        node_shared_http_parser: false,</div><div class="line">    //        node_shared_libuv: false,</div><div class="line">    //        node_shared_openssl: false,</div><div class="line">    //        node_shared_zlib: false,</div><div class="line">    //        node_tag: &apos;&apos;,</div><div class="line">    //        node_use_dtrace: false,</div><div class="line">    //        node_use_etw: true,</div><div class="line">    //        node_use_lttng: false,</div><div class="line">    //        node_use_openssl: true,</div><div class="line">    //        node_use_perfctr: true,</div><div class="line">    //        openssl_fips: &apos;&apos;,</div><div class="line">    //        openssl_no_asm: 0,</div><div class="line">    //        python: &apos;C:\\Python27\\python.exe&apos;,</div><div class="line">    //        target_arch: &apos;x64&apos;,</div><div class="line">    //        v8_enable_gdbjit: 0,</div><div class="line">    //        v8_enable_i18n_support: 1,</div><div class="line">    //        v8_no_strict_aliasing: 1,</div><div class="line">    //        v8_optimized_debug: 0,</div><div class="line">    //        v8_random_seed: 0,</div><div class="line">    //        v8_use_snapshot: 1,</div><div class="line">    //        want_separate_host_toolset: 0 &#125; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>TODO demo process.disconnect() &amp; process.disconnected</li>
<li>关闭通向父进程的IPC通道，让子进程在没有任何存活连接的情况下优雅退出</li>
<li>和ChildProcess.disconnect()相同</li>
<li>若nodejs没有开启一个IPC通道，这个方法会是undefined<br>*</li>
<li>IPC(Internet Process Connection)是共享”命名管道”的资源，它是为了让进程间通信而开放的命名管道，</li>
<li>通过提供可信任的用户名和口令，连接双方可以建立安全的通道并以此通道进行加密数据的交换，</li>
<li>从而实现对远程计算机的访问。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function t6()&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>可以写入process.env，不过只在进程内有效</li>
<li>$ node -e ‘process.env.foo = “bar”‘ &amp;&amp; echo $foo  这样是没有效果的<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function t7()&#123;</div><div class="line">    process.env.zcz=&quot;test&quot;;</div><div class="line">    console.log(process.env)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>process.exit() 进程退出，退出码不写的话，默认是success的状态码 0</li>
<li>process.exitCode  为process.exit设置退出状态码，若exit方法不传状态码，则使用此处设置的，若传入了状态码参数，则使用传入的参数<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function t8()&#123;</div><div class="line">    process.exitCode=3;</div><div class="line">    console.log(process.exitCode)</div><div class="line"></div><div class="line">    process.on(&quot;exit&quot;,function()&#123;</div><div class="line">        console.log(arguments);</div><div class="line">    &#125;);</div><div class="line">    process.exit(1);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>only available on POSIX platforms<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function t9()&#123;</div><div class="line">    console.log(&apos;Current gid: &apos; + process.getegid());</div><div class="line">    console.log(&apos;Current uid: &apos; + process.geteuid());</div><div class="line">    console.log(&apos;Current gid: &apos; + process.getgid());</div><div class="line">    console.log(&apos;Current gid: &apos; + process.getgroups());</div><div class="line">    //process.initgroups(user, extra_group)</div><div class="line">    //process.setegid(id);</div><div class="line">    //process.seteuid(id)</div><div class="line">    //process.setgid(id)</div><div class="line">    //process.setgroups(groups)</div><div class="line">    //process.setuid(id)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>得到与过去某一时间点的时间差，结果是[秒,纳秒],精确且不受系统时钟影响<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function t10()&#123;</div><div class="line">    var time = process.hrtime();</div><div class="line">    // [ 1800216, 25 ]</div><div class="line">    setTimeout(function() &#123;</div><div class="line">        var diff = process.hrtime(time);</div><div class="line">        // [ 1, 552 ]</div><div class="line">        console.log(&apos;benchmark took %d nanoseconds&apos;, diff[0] * 1e9 + diff[1]);</div><div class="line">        // benchmark took 1000000527 nanoseconds</div><div class="line">    &#125;, 1000);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>process.kill(pid[, signal]) 向id为pid的进程发出信号，长的像kill，但是实际上只是一个发信号的函数</li>
<li>下面node官网的demo在win7x64下会报错：Error: kill ENOSYS</li>
<li>原因是这个时间只能由windows的cmd关闭引发…  其他平台下是可以由代码发出的</li>
<li>注释掉最后一句，手动X掉cmd，会先输出Got SIGHUP signal，两秒后cmd窗口才关闭</li>
<li>SIGHUP信号在windows中发生10s后，无论进程是否自己退出，都会强制干掉node进程<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function t11()&#123;</div><div class="line">    process.on(&apos;SIGHUP&apos;, function() &#123;</div><div class="line">        console.log(&apos;Got SIGHUP signal.&apos;);</div><div class="line">    &#125;);</div><div class="line">    setTimeout(function() &#123;</div><div class="line">        console.log(&apos;Exiting.&apos;);</div><div class="line">        process.exit(0);</div><div class="line">    &#125;, 2000);</div><div class="line">    process.kill(process.pid, &apos;SIGHUP&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>process.mainModule 获取require.main的另一种方法</li>
<li>不同的是如果在运行时main module发生变化require.main可能仍指向变化之前的main模块</li>
<li>不过一般情况下认为这俩指向的是同一个模块是没问题的<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function t12()&#123;</div><div class="line">    console.log(process.mainModule===require.main);//true</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>process.memoryUsage 返回内存使用情况</li>
<li>heapTotal代表已申请到的堆内存，heapUsed当前使用的内存，rss(resident set size)进程的常驻内存</li>
<li>{ rss: 17272832, heapTotal: 9275392, heapUsed: 4059760 }<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function t13()&#123;</div><div class="line">    var util = require(&apos;util&apos;);</div><div class="line">    console.log(util.inspect(process.memoryUsage()));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>process.nextTick 作用和setTimeout(cb,0)相似，但是其回调的优先级更高，会被放在事件队列的最前面，而settimeout是放在最后面.</li>
<li>理解此函数需要理解js的event loop概念，这是一个很重要的概念，理解如下：</li>
<li>1.js引擎执行时，会把要执行的语句压入一个先入后出的执行栈(call stack)</li>
<li>2.异步事件完成后，会向一个先进先出的任务队列(task queue)压入需要执行的事件回调(callback)</li>
<li>3.浏览器中涉及到事件队列的东西：timer、dom evnet、ajax、dom渲染(注意，对dom的渲染并不是立即生效的，大多数浏览器16ms渲染一次)、</li>
<li>fileReader相关等等</li>
<li>4.event loop，js引擎每次把call stack里边的任务执行空之后，都去task queue里边去找，看有没有需要执行的callback，有的话就依次压入call stack执行</li>
<li>5.process.nextTick的特点就在于，它没有任何event触发条件，会无条件立即将callback放入task queue的最前面，因而一旦js引擎将call stack执行空，</li>
<li>下一次event loop将最先执行nextTick的callback，效率最高。有些运行环境下，setTimeout的时间是有最小限制的，比如4ms啥的，nextTick不会</li>
<li>6.做javascript程序的时候应该永远考虑异步思想，不要做同步操作，那样会阻塞evnet loop</li>
<li>demo中输出顺序：by nextTick — by settimeout0  — sleep3  —  3  —  5</li>
<li>说明nextTick将事件放在执行栈头部，而setTimeout在尾部<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">function t14()&#123;</div><div class="line">    var a=1;</div><div class="line">    var b=a+1;</div><div class="line">    setTimeout(function()&#123;</div><div class="line">        console.log(&quot;init by setTimeout 0&quot;)</div><div class="line">    &#125;,0);</div><div class="line">    setTimeout(function()&#123;</div><div class="line">        console.log(&quot;5&quot;);</div><div class="line">    &#125;,5000);</div><div class="line">    setTimeout(function()&#123;</div><div class="line">        console.log(&quot;sleep 3&quot;);</div><div class="line">        sleep(3000)</div><div class="line">    &#125;,3000);</div><div class="line">    setTimeout(function()&#123;</div><div class="line">        console.log(&quot;3&quot;);</div><div class="line">    &#125;,3000);</div><div class="line">    process.nextTick(function()&#123;</div><div class="line">        console.log(&quot;init by nextTick&quot;)</div><div class="line">    &#125;);</div><div class="line">    function sleep(t)&#123;</div><div class="line">        var time=process.uptime();</div><div class="line">        while(process.uptime()-time&lt;t/1000)&#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>pid 进程id</li>
<li>platform 操作系统平台信息</li>
<li>release 当前node发布信息</li>
<li>title 在ps中显示的进程名字</li>
<li>version node版本</li>
<li>versions 一个node版本和它依赖项目版本的集合</li>
<li>process.umask([mask]) 设置或获取node进程创建文件和文件夹的权限，如果是设置操作,将返回原先的mask,如果是读取,返回当前的mask.</li>
<li>process.uptime()() nodejs进程已经运行的时间(s)<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function t15()&#123;</div><div class="line">    console.log(&apos;This process is pid &apos; + process.pid);</div><div class="line">    //What platform you&apos;re running on: &apos;darwin&apos;, &apos;freebsd&apos;, &apos;linux&apos;, &apos;sunos&apos; or &apos;win32&apos;</div><div class="line">    console.log(&apos;This platform is &apos; + process.platform);</div><div class="line">    console.log(process.release);</div><div class="line">    console.log(process.title);</div><div class="line">    console.log(process.version);</div><div class="line">    console.log(process.versions);</div><div class="line">    process.umask(0022);</div><div class="line">    var t=process.uptime();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>process.send 如果nodejs是在有IPC通道的情况下启动，可以通过process.send向其父进程发送消息</li>
<li>父进程中 ‘message’ 事件会响应消息<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function t16()&#123;</div><div class="line">    //用法见下面child_process部分</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>process.stdin/stdout  系统I/O 输入输出</li>
<li>process.stderr 一个指向错误的输出流，对该流的写入是阻塞的<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function t17()&#123;</div><div class="line">    process.stdin.resume();//默认是暂停的，此方法开始接收</div><div class="line">    process.stdin.setEncoding(&apos;utf8&apos;);</div><div class="line"></div><div class="line">    process.stdin.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">        process.stdout.write(&apos;data: &apos; + chunk);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    process.stdin.on(&apos;end&apos;, function () &#123;</div><div class="line">        process.stdout.write(&apos;end&apos;);</div><div class="line">    &#125;);</div><div class="line">    console.log = function(d) &#123;</div><div class="line">        process.stdout.write(d + &apos;\n&apos;);</div><div class="line">    &#125;;</div><div class="line">    //可以用来与其他进程的通信</div><div class="line">    var fs = require(&apos;fs&apos;);</div><div class="line">    var zlib = require(&apos;zlib&apos;);</div><div class="line"></div><div class="line">    fs.createReadStream(&apos;wow.txt&apos;)</div><div class="line">        .pipe(zlib.createGzip())</div><div class="line">        .pipe(process.stdout);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p>
<ul>
<li><p>下面是child_process的文档部分                 <em><br><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em>/<br>/*<br>ChildProcess对象不能直接new出来，通过spawn(), exec(), execFile(), or fork() 四个方法返回</p>
<p>*/</p>
</li>
</ul>
<p>/**</p>
<ul>
<li>子进程相关事件</li>
<li>close</li>
<li>disconnect</li>
<li>error</li>
<li>exit</li>
<li>message<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function t18()&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>child.disconnect()  child.disconnected</li>
<li>TODO demo<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function t19()&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>child.send(message[, sendHandle][, callback])</li>
<li>{cmd: ‘NODE<em>xxx’} 如果消息对象里边有以cmd为key，NODE</em>为value前缀的消息，则不会触发message事件，因为这种消息是node内核自己使用的</li>
<li>会触发internalMessage事件</li>
<li>sendHandle参数用来发送一个socket对象到子进程。子进程可以在message事件中获取此socket对象</li>
<li>callback在消息成功发送时无参数，失败时得到一个Error对象</li>
<li>child.send方法若成功发送消息则返回true，若消息通道已经关闭或者缓存未发送的消息达到阈值，则返回false<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function t20()&#123;</div><div class="line">    var cp = require(&apos;child_process&apos;);</div><div class="line">    var n = cp.fork(__dirname + &apos;/child.js&apos;);</div><div class="line">    n.on(&apos;message&apos;, function(m) &#123;</div><div class="line">        console.log(&apos;PARENT got message:&apos;, m);</div><div class="line">    &#125;);</div><div class="line">    n.send(&#123; hello: &apos;world&apos; &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>child.send 发送一个server socket对象到子进程</li>
<li>此时主线程和子线程同时处理请求<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function t21()&#123;</div><div class="line">    var child = require(&apos;child_process&apos;).fork(&apos;child2.js&apos;);</div><div class="line">    // Open up the server object and send the handle.</div><div class="line">    var server = require(&apos;net&apos;).createServer();</div><div class="line">    server.on(&apos;connection&apos;, function (socket) &#123;</div><div class="line">        socket.end(&apos;handled by parent&apos;);</div><div class="line">    &#125;);</div><div class="line">    server.listen(1337, function() &#123;</div><div class="line">        child.send(&apos;server&apos;, server);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>child.stdio,一个数组，里边存放着子进程的io对象，受创建进程时options.stdio配置影响</li>
<li>具体配置见下面的child_process.spawn</li>
<li>下面的demo中仅child.stdout存在<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function t22()&#123;</div><div class="line">    var assert = require(&apos;assert&apos;);</div><div class="line">    var fs = require(&apos;fs&apos;);</div><div class="line">    var child_process = require(&apos;child_process&apos;);</div><div class="line">    child = child_process.spawn(&apos;node&apos;,[&quot;child3.js&quot;], &#123;</div><div class="line">        stdio: [</div><div class="line">            0, // 子进程使用父进程的stdin</div><div class="line">            &apos;pipe&apos;, // 将子进程的stdout pipe到父进程   这个父进程怎么接收呢？奇怪...</div><div class="line">            fs.openSync(&apos;err.out&apos;, &apos;w&apos;) // direct child&apos;s stderr to a file</div><div class="line">        ]</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    //仅仅child.stdout存在，child.stdin和stderr都是null</div><div class="line">    assert.equal(child.stdio[0], null);</div><div class="line">    assert.equal(child.stdio[0], child.stdin);</div><div class="line">    assert(child.stdout);</div><div class="line">    assert.equal(child.stdio[1], child.stdout);</div><div class="line">    assert.equal(child.stdio[2], null);</div><div class="line">    assert.equal(child.stdio[2], child.stderr);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>child_process.exec(command[, options], callback)</li>
<li>参数分别是：命令字符，命令执行环境配置对象，回调函数，回调函数提供err对象,stdout buffer,stderr buffer</li>
<li>child_process.execFile(file[, args][, options][, callback])</li>
<li>和child_process.exec大致相同，第二个参数args是一个数组，里边是执行参数<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function t23()&#123;</div><div class="line">    var exec = require(&apos;child_process&apos;).exec;</div><div class="line">    var exec2 = require(&apos;child_process&apos;).execFile;</div><div class="line">    var child=exec(&quot;ipconfig&quot;,function(err,stdout,stderr)&#123;</div><div class="line">        console.log(&quot;exec&quot;,stdout.toString(&quot;utf8&quot;))</div><div class="line">    &#125;)</div><div class="line">    var child2=exec2(&quot;cmdfile.cmd&quot;,function(err,stdout,stderr)&#123;</div><div class="line">        console.log(&quot;exec2&quot;,stdout.toString(&quot;utf8&quot;))</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>child_process.spawn(command[, args][, options])</li>
<li>child_process.spawnSync(command[, args][, options]) 同步方法，返回一个object，包括子进程的stdio数组等</li>
<li>command 要执行的命令，例如 node</li>
<li>args 执行参数  如  xxx.js</li>
<li>options 执行选项：</li>
<li>–cwd 字符串，执行路径</li>
<li>–env 对象，执行环境参数</li>
<li>–stdio 数组或字符串，进程标准io设置：</li>
<li>—- ‘pipe’ 相当于 [‘pipe’, ‘pipe’, ‘pipe’]，stdin,stdout,stderr均pipe到父进程中，在父进程中可以通过child.stdin/put/err 来访问</li>
<li>—- ‘ignore’ - 相当于[‘ignore’, ‘ignore’, ‘ignore’] 都是null</li>
<li>—- ‘inherit’ - 相当于[process.stdin, process.stdout, process.stderr] or [0,1,2] 继承，直接使用父进程的stdio</li>
<li>—- *数组中有’ipc’时，会在子进程和父进程之间开启ipc通道通信，此时可以通过child.send给子进程发消息，子进程中也可以监听message消息</li>
<li>—- <em>数组中的取值可能为：pipe、ignore、ipc、一个Stream、一个正整数（fs.openSync返回的一个文件描述符）、null/undefined
</em>/<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function t24()&#123;</div><div class="line">    var child_process=require(&apos;child_process&apos;);</div><div class="line">    var child=child_process.spawn(&quot;ipconfig&quot;,&#123;</div><div class="line">        stdio:&apos;inherit&apos; //此时用pipe或者ignore就不会在控制台中暑促ipconfig的结果</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>options.detached 让子线程可以独立在父线程之外长时间运行</li>
<li>child.unref(); 让父线程退出的时候不等待此子线程</li>
<li>TODO 这个demo没懂<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function t25()&#123;</div><div class="line">    var fs = require(&apos;fs&apos;),</div><div class="line">        spawn = require(&apos;child_process&apos;).spawn,</div><div class="line">        out = fs.openSync(&apos;./out.log&apos;, &apos;a&apos;),</div><div class="line">        err = fs.openSync(&apos;./out.log&apos;, &apos;a&apos;);</div><div class="line"></div><div class="line">    var child = spawn(&apos;ls&apos;, [], &#123;</div><div class="line">        detached: true,</div><div class="line">        stdio: [ &apos;ignore&apos;, out, err ]</div><div class="line">    &#125;);</div><div class="line">    child.unref();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>t25();</p>
]]></content>
    <summary type="html">
    <![CDATA[<ul>
<li>exit事件和beforeExit事件</li>
<li>exit事件提供一个退出状态码<br>###　进程退出状态码：</li>
<li>1 Uncaught Fatal Exception   因没有被捕获的异常而退出，这里的没有被捕获指的是没有被程序中代码]]>
    </summary>
    
      <category term="nodejs" scheme="http://www.zoucz.com/blog/tags/nodejs/"/>
    
      <category term="process" scheme="http://www.zoucz.com/blog/tags/process/"/>
    
      <category term="nodejs" scheme="http://www.zoucz.com/blog/categories/nodejs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为什么英语对编程很重要？]]></title>
    <link href="http://www.zoucz.com/blog/2016/02/02/english-coding/"/>
    <id>http://www.zoucz.com/blog/2016/02/02/english-coding/</id>
    <published>2016-02-02T08:50:49.000Z</published>
    <updated>2016-12-21T16:42:00.000Z</updated>
    <content type="html"><![CDATA[<p>学习编程以来，每次理解比较重要的语言功能时，总爱用一些比较容易理解的东西来做比喻，方便理解。<br>比如对nodejs中stream和buffer的理解： <a href="http://www.cnblogs.com/tzyy/p/5108724.html" target="_blank" rel="external">http://www.cnblogs.com/tzyy/p/5108724.html</a>   </p>
<p>再或者项目源码中的一些属性、方法、事件的命名，往往也需要仔细阅读代码或者文档才能理解它们的作用<br><img src="http://zoucz.com/blogimgs/2016-02-02/1454399796072.png" alt="">   </p>
<p><img src="http://zoucz.com/blogimgs/2016-02-02/1454399868606.png" alt="">    </p>
<p>很多人说学好英语对编程很重要，现在我倒是觉得，如果我们在国内从事编程工作，周围的语言环境是汉语环境，学好英语很难说对理解代码有很大的帮助。<br>英语对编程有帮助的地方应该是母语是英语的人，从小在那个语言环境中长大，这些我们需要读遍代码或者查看文档才能明白的代码，在他们看来可能只是看个名字就能理解的清清楚楚。<br>母语是汉语的人看代码，可能需要打比方来方便理解，但是母语是英语的人看来，这些程序本来就已经说的明明白白了，这样他们的精力就更容易放在怎样写出更好的代码上面，而我们还在理解和记忆上下功夫。    </p>
<p>对于个人而言，只有付出比英语母语的人多好几倍的时间和汗水，来熟悉那些经常在项目源码中出现的词汇和套路，熟能生巧，看的代码多到一定地步之后，这个劣势就能被抵消掉了…<br>不过我觉得中国有很多智商很高，但是很懒的人，在还没有到达那一地步的时候就放弃了，因而在我们国家诞生的大型经典项目不多，实在可惜…<br>整个计算机行业、互联网行业目前实际上还是以英语为主导的，抛弃民族国家成见而言，大家都去使用英语确实有助于人类的发展啊。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>学习编程以来，每次理解比较重要的语言功能时，总爱用一些比较容易理解的东西来做比喻，方便理解。<br>比如对nodejs中stream和buffer的理解： <a href="http://www.cnblogs.com/tzyy/p/5108724.html" target]]>
    </summary>
    
      <category term="编程杂谈" scheme="http://www.zoucz.com/blog/tags/%E7%BC%96%E7%A8%8B%E6%9D%82%E8%B0%88/"/>
    
      <category term="杂谈" scheme="http://www.zoucz.com/blog/categories/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ISO日期格式标准]]></title>
    <link href="http://www.zoucz.com/blog/2016/01/29/date-iso/"/>
    <id>http://www.zoucz.com/blog/2016/01/29/date-iso/</id>
    <published>2016-01-29T06:20:33.000Z</published>
    <updated>2016-12-21T16:42:00.000Z</updated>
    <content type="html"><![CDATA[<h1 id="时区简单理解"><a href="#时区简单理解" class="headerlink" title="时区简单理解"></a>时区简单理解</h1><p><a href="https://zh.wikipedia.org/wiki/%E6%97%B6%E5%8C%BA" target="_blank" rel="external">https://zh.wikipedia.org/wiki/%E6%97%B6%E5%8C%BA</a></p>
<p>上面的链接是时区的wiki说明，下面说说我记住的部分：</p>
<p>GMT时区是格林威治标准时间，我把它理解为 “真实时间”</p>
<p>UTC时区是根据GMT得来的“世界标准时间”，它的时间和GMT是相同的</p>
<p>CST可以指下列的时区：</p>
<p>澳洲中部时间，Central Standard Time (Australia)<br>中部标准时区（北美洲），Central Standard Time (North America)<br>北京时间，China Standard Time<br>古巴标准时间，Cuba Standard Time，参见北美东部时区</p>
<p>其中我们所在的时区背景时间  CST=UTC+8小时，也就是说，真实时间是0点的时候，背景时间是8点</p>
<h1 id="ISO-8601日期格式标准"><a href="#ISO-8601日期格式标准" class="headerlink" title="ISO_8601日期格式标准"></a>ISO_8601日期格式标准</h1><p><a href="https://zh.wikipedia.org/wiki/ISO_8601" target="_blank" rel="external">https://zh.wikipedia.org/wiki/ISO_8601</a></p>
<p>上面是日期格式标准的wiki</p>
<p>当前的UTC时间是2016-01-07T01:58Z，其中Z是4位数字格式的时间偏移量，不写的时候默认不偏移。</p>
<p> 其中，字母T代表使用UTC时间，字母Z代表时间偏移量，实际写法中字母Z应该被偏移量替换，例如 “2017-1-7T10:21+0800”或者”2017-1-7T10:21-0800”，字母Z被+0800和-0800替换了。</p>
<p>在浏览器中直接new一个date对象，因为我们处于UTC+0800的时区，所以控制台给我们打印出来的时间是GMT+0800的时间</p>
<p><img src="http://zoucz.com/blogimgs/2016-01-29/1454048193816.png" alt=""></p>
<p>2016-01-07T00:00 代表UTC时区1月7日0时0分（在控制台中显示UTC+0800时区为8时0分）</p>
<p><img src="http://zoucz.com/blogimgs/2016-01-29/1454048206377.png" alt=""></p>
<p> 2016-01-07T00:00 0800 代表UTC+0800时区1月7日0时0分，2016-01-07T00:00 -0800 代表UTC-0800时区1月7日0时0分，在控制台中显示分别如下<br><img src="http://zoucz.com/blogimgs/2016-01-29/1454048217856.png" alt="">    </p>
<p>通过日期字符串new一个Date对象，输入的时间字符串是2016-1-7 10:21，没有带ISO标准的“T”字母，因此浏览器认为我们想输入的是当地时间<br><img src="http://zoucz.com/blogimgs/2016-01-29/1454048233627.png" alt=""></p>
<h1 id="HTML5-input标签datetime属性"><a href="#HTML5-input标签datetime属性" class="headerlink" title="HTML5 input标签datetime属性"></a>HTML5 input标签datetime属性</h1><p>下面问题来了，我要在页面上输入一个时间，存入数据库，上面说了那么多时区，那么用户在页面上输入的时间应该是哪个时区的呢，传到server，存入db的应该又是哪个时区的呢？</p>
<p>经测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;input type=&quot;datetime&quot;  /&gt;  chrome上是不支持的</div><div class="line">&lt;input type=&quot;datetime-local&quot; /&gt; chrome支持</div></pre></td></tr></table></figure>
<p>Google了一下据说是因为datetime输入框输入的是本地时区，考虑到时区的问题chrome没有支持此输入类型，会降级为text类型</p>
<p>datetime-local输入类型chrome是支持的，获取的value格式是：</p>
<p>“2016-1-7T10:21”</p>
<p>如上面所述，这个时间是标准UTC时间，这种时间从前端到后台到存入db，都是不会发生错误的。</p>
<p>但是对用户来说，他填写表单的时候想的时间肯定是他所在位置的本地时间，比如我输入”2016-1-7 10:21”，我真实想输入的时间是”2016-1-7T10:21+0800”，而不是”2016-1-7T10:21”。</p>
<p>为了支持这种情况，我需要把”2016-1-7T10:21”转换为用户真实想要的当地时间”2016-1-7 10:21”，于是”2016-1-7 10:21”.replace(“T”,” “)，它实际代表的真实时间(UTC时间)是”2016-1-7T10:21+0800”</p>
<p>这样在前端是没问题了，但是传到后端之后，这样的非ISO标准时间是没有携带时区信息的，服务器收到之后会将这个时间安装服务器所在时区来处理，处理之后所代表的真实时间就和用户输入的真实时间不同了。所以我们在前端得把时间转换为ISO标准时间格式再传给服务器，这样服务器就能明白用户输入的真正的时间了，另一种方法，也可以把时间用毫秒数表示，传到后端，不过这种方式可读性不太好。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 1.将字面时间转化为本地时间  2.将本地时间转换为真实GMT时间传入后台</div><div class="line">    function getRealGMT(datetime)&#123;</div><div class="line">        datetime=datetime.replace(&quot;T&quot;,&quot; &quot;);</div><div class="line">        var temp=new Date(datetime);</div><div class="line">        var realGMT=temp.getTime()+temp.getTimezoneOffset()*60000;</div><div class="line">        return new Date(realGMT).format(&quot;yyyy-MM-ddThh:mm&quot;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>转换效果如下：<br><img src="http://zoucz.com/blogimgs/2016-01-29/1454048254331.png" alt=""></p>
<h1 id="mysql时区"><a href="#mysql时区" class="headerlink" title="mysql时区"></a>mysql时区</h1><p>mysql可通过 show variables like ‘%time_zone%’；命令来查看数据库设置的时区。我们的CST时区代表的是中国区的时区，即UTC+0800<br>所以服务器把从前端收到的ISO日期 “2016-1-7T02:21”收到之后，写入mysql的datetime字段，mysql的datetime字段会根据它的CST时区把日期转换过来，于是显示的日期就是”2016-1-7 10:21”，代表的真实时间是”2016-1-7T10:21+0800”</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="时区简单理解"><a href="#时区简单理解" class="headerlink" title="时区简单理解"></a>时区简单理解</h1><p><a href="https://zh.wikipedia.org/wiki/%E6%97%B6%E5%8C]]>
    </summary>
    
      <category term="前端开发" scheme="http://www.zoucz.com/blog/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="时区" scheme="http://www.zoucz.com/blog/tags/%E6%97%B6%E5%8C%BA/"/>
    
      <category term="前端开发" scheme="http://www.zoucz.com/blog/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[详解Javascript中正则表达式的使用]]></title>
    <link href="http://www.zoucz.com/blog/2016/01/29/javascript-RegExp/"/>
    <id>http://www.zoucz.com/blog/2016/01/29/javascript-RegExp/</id>
    <published>2016-01-29T06:07:32.000Z</published>
    <updated>2016-12-21T16:42:00.000Z</updated>
    <content type="html"><![CDATA[<p>本文章转自我的博客园博客 <a href="http://www.cnblogs.com/tzyy/p/4927476.html" target="_blank" rel="external">原文地址</a>     </p>
<p>正则表达式用来处理字符串特别好用，在JavaScript中能用到正则表达式的地方有很多，本文对正则表达式基础知识和Javascript中正则表达式的使用做一个总结。</p>
<p>第一部分简单列举了正则表达式在JavaScript中的使用场景；第二部分详细介绍正则表达式的基础知识，写出一些例子方便理解。</p>
<p>本文的内容是我自己看完正则表达式写法，和犀牛书中js正则表达式的章节后的总结，所以内容可能会有疏漏和不严谨的地方。若有大神路过发现文中错误的地方，欢迎斧正！</p>
<h1 id="Javascript中正则表达式的使用"><a href="#Javascript中正则表达式的使用" class="headerlink" title="Javascript中正则表达式的使用"></a>Javascript中正则表达式的使用</h1><p>一个正则表达式可以认为是对一种字符片段的特征描述，而它的作用就是从一堆字符串中找出满足条件的子字符串。比如我在JavaScript中定义一个正则表达式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> reg=<span class="regexp">/hello/</span>    或者  <span class="keyword">var</span> reg=<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"hello"</span>)</div></pre></td></tr></table></figure>
<p>那么这个正则表达式可以用来从一堆字符串中找出 hello 这个单词。而“找出”这个动作，其结果可能是找出第一个hello的位置、用别的字符串替换hello、找出所有hello等等。下面就列举一下JavaScript中可以使用正则表达式的函数，简单介绍一下这些函数的作用，更复杂的用法会在第二部分中介绍。</p>
<h2 id="String-prototype-search方法"><a href="#String-prototype-search方法" class="headerlink" title="String.prototype.search方法"></a>String.prototype.search方法</h2><p>用来找出原字符串中某个子字符串首次出现的index，没有则返回-1</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"abchello"</span>.search(<span class="regexp">/hello/</span>);  <span class="comment">//  3</span></div></pre></td></tr></table></figure>
<h2 id="String-prototype-replace方法"><a href="#String-prototype-replace方法" class="headerlink" title="String.prototype.replace方法"></a>String.prototype.replace方法</h2><p>用来替换字符串中的子串</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"abchello"</span>.replace(<span class="regexp">/hello/</span>,<span class="string">"hi"</span>);   <span class="comment">//  "abchi"</span></div></pre></td></tr></table></figure>
<h2 id="String-prototype-split方法"><a href="#String-prototype-split方法" class="headerlink" title="String.prototype.split方法"></a>String.prototype.split方法</h2><p>用来分割字符串</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"abchelloasdasdhelloasd"</span>.split(<span class="regexp">/hello/</span>);  <span class="comment">//["abc", "asdasd", "asd"]</span></div></pre></td></tr></table></figure>
<h2 id="String-prototype-match方法"><a href="#String-prototype-match方法" class="headerlink" title="String.prototype.match方法"></a>String.prototype.match方法</h2><p>用来捕获字符串中的子字符串到一个数组中。默认情况下只捕获一个结果到数组中，正则表达式有”全局捕获“的属性时(定义正则表达式的时候添加参数g)，会捕获所有结果到数组中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">"abchelloasdasdhelloasd"</span>.match(<span class="regexp">/hello/</span>);  <span class="comment">//["hello"]</span></div><div class="line"><span class="string">"abchelloasdasdhelloasd"</span>.match(<span class="regexp">/hello/g</span>);  <span class="comment">//["hello","hello"]</span></div></pre></td></tr></table></figure>
<p>作为match参数的正则表达式在是否拥有全局属性的情况下，match方法的表现还不一样，这一点会在后边的正则表达式分组中讲到。</p>
<h2 id="RegExp-prototype-test方法"><a href="#RegExp-prototype-test方法" class="headerlink" title="RegExp.prototype.test方法"></a>RegExp.prototype.test方法</h2><p>用来测试字符串中是否含有子字符串</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/hello/.test(<span class="string">"abchello"</span>);  <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h2 id="RegExp-prototype-exec方法"><a href="#RegExp-prototype-exec方法" class="headerlink" title="RegExp.prototype.exec方法"></a>RegExp.prototype.exec方法</h2><p>和字符串的match方法类似，这个方法也是从字符串中捕获满足条件的字符串到数组中，但是也有两个区别。</p>
<ol>
<li>exec方法一次只能捕获一份子字符串到数组中，无论正则表达式是否有全局属性</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> reg=<span class="regexp">/hello/g</span>;</div><div class="line">reg.exec(<span class="string">"abchelloasdasdhelloasd"</span>);   <span class="comment">// ["hello"]</span></div></pre></td></tr></table></figure>
<ol>
<li>正则表达式对象(也就是JavaScript中的RegExp对象)有一个lastIndex属性，用来表示下一次从哪个位置开始捕获，每一次执行exec方法后，lastIndex就会往后推，直到找不到匹配的字符返回null，然后又从头开始捕获。 这个属性可以用来遍历捕获字符串中的子串。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> reg=<span class="regexp">/hello/g</span>;</div><div class="line">reg.lastIndex; <span class="comment">//0</span></div><div class="line">reg.exec(<span class="string">"abchelloasdasdhelloasd"</span>); <span class="comment">// ["hello"]</span></div><div class="line">reg.lastIndex; <span class="comment">//8</span></div><div class="line">reg.exec(<span class="string">"abchelloasdasdhelloasd"</span>); <span class="comment">// ["hello"]</span></div><div class="line">reg.lastIndex; <span class="comment">//19</span></div><div class="line">reg.exec(<span class="string">"abchelloasdasdhelloasd"</span>); <span class="comment">// null</span></div><div class="line">reg.lastIndex; <span class="comment">//0</span></div></pre></td></tr></table></figure>
<h1 id="正则表达式基础"><a href="#正则表达式基础" class="headerlink" title="正则表达式基础"></a>正则表达式基础</h1><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p> 上面第一节以/hello/为例，但是实际应用中可能会遇到这样的需求： 匹配一串不确定的数字、匹配开始的位置、匹配结束的位置、匹配空白符。此时就可以用到元字符。</p>
<p>元字符：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//匹配数字:  \d</span></div><div class="line"><span class="string">"ad3ad2ad"</span>.match(<span class="regexp">/\d/g</span>);  <span class="comment">// ["3", "2"]</span></div><div class="line"><span class="comment">//匹配除换行符以外的任意字符:  .</span></div><div class="line"><span class="string">"a\nb\rc"</span>.match(<span class="regexp">/./g</span>);  <span class="comment">// ["a", "b", "c"]</span></div><div class="line"><span class="comment">//匹配字母或数字或下划线 ： \w</span></div><div class="line"><span class="string">"a5_  汉字@!-="</span>.match(<span class="regexp">/\w/g</span>);  <span class="comment">// ["a", "5", "_"]</span></div><div class="line"><span class="comment">//匹配空白符:\s</span></div><div class="line"><span class="string">"\n \r"</span>.match(<span class="regexp">/\s/g</span>);  <span class="comment">//[" ", " ", ""] 第一个结果是\n，最后一个结果是\r</span></div><div class="line"><span class="comment">//匹配【单词开始或结束】的位置 ： \b</span></div><div class="line"><span class="string">"how are you"</span>.match(<span class="regexp">/\b\w/g</span>);  <span class="comment">//["h", "a", "y"] </span></div><div class="line"><span class="comment">// 匹配【字符串开始和结束】的位置:  开始 ^ 结束 $</span></div><div class="line"><span class="string">"how are you"</span>.match(<span class="regexp">/^\w/g</span>); <span class="comment">// ["h"]</span></div></pre></td></tr></table></figure>
<p>反义元字符，写法就是把上面的小写字母变成大写的，比如 ， 匹配所有不是数字的字符： \D</p>
<p>另外还有一些用来表示重复的元字符，会在下面的内容中介绍。</p>
<h2 id="字符范围"><a href="#字符范围" class="headerlink" title="字符范围"></a>字符范围</h2><p>在 [] 中使用符号 -  ，可以用来表示字符范围。如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 匹配字母 a-z 之间所有字母</span></div><div class="line">/[a-z]/</div><div class="line"><span class="comment">// 匹配Unicode中 数字 0 到 字母 z 之间的所有字符</span></div><div class="line">/[<span class="number">0</span>-z]/ </div><div class="line"><span class="comment">// unicode编码查询地址：</span></div><div class="line"><span class="comment">//https://en.wikibooks.org/wiki/Unicode/Character_reference/0000-0FFF</span></div><div class="line"><span class="comment">//根据上面的内容，我们可以找出汉字的Unicode编码范围是 \u4E00 到 \u9FA5，所以我们可以写一个正则表达式来判断一个字符串中是否有汉字</span></div><div class="line">/[\u4E00-\u9FA5]/.test(<span class="string">"测试"</span>);  <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h2 id="重复-amp-贪婪与懒惰"><a href="#重复-amp-贪婪与懒惰" class="headerlink" title="重复 &amp; 贪婪与懒惰"></a>重复 &amp; 贪婪与懒惰</h2><p>首先来讲重复，当我们希望匹配一些重复的字符时，就需要用到一些和重复相关的正则表达式，写法如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//重复n次 &#123;n&#125;</span></div><div class="line"><span class="string">"test12"</span>.match(<span class="regexp">/test\d&#123;3&#125;/</span>); <span class="comment">// null</span></div><div class="line"><span class="string">"test123"</span>.match(<span class="regexp">/test\d&#123;3&#125;/</span>); <span class="comment">// ["test123"]</span></div><div class="line"><span class="comment">//重复n次或更多次  &#123;n,&#125;</span></div><div class="line"><span class="string">"test123"</span>.match(<span class="regexp">/test\d&#123;3,&#125;/</span>); <span class="comment">//  ["test123"]</span></div><div class="line"><span class="comment">//重复n到m次</span></div><div class="line"><span class="string">"test12"</span>.match(<span class="regexp">/test\d&#123;3,5&#125;/</span>); <span class="comment">//  null</span></div><div class="line"><span class="string">"test12345"</span>.match(<span class="regexp">/test\d&#123;3,5&#125;/</span>);  <span class="comment">// ["test12345"]</span></div><div class="line"><span class="string">"test12345678"</span>.match(<span class="regexp">/test\d&#123;3,5&#125;/</span>);  <span class="comment">// ["test12345"]</span></div><div class="line"><span class="comment">// 匹配字符test后边跟着数字，数字重复0次或多次</span></div><div class="line"><span class="string">"test"</span>.match(<span class="regexp">/test\d*/</span>); <span class="comment">// ["test"]</span></div><div class="line"><span class="string">"test123"</span>.match(<span class="regexp">/test\d*/</span>); <span class="comment">// ["test123"]</span></div><div class="line"><span class="comment">//重复一次或多次</span></div><div class="line"><span class="string">"test"</span>.match(<span class="regexp">/test\d+/</span>) ; <span class="comment">// null</span></div><div class="line"><span class="string">"test1"</span>.match(<span class="regexp">/test\d*/</span>); <span class="comment">//["test1"]</span></div><div class="line"><span class="comment">//重复一次或0次</span></div><div class="line"><span class="string">"test"</span>.match(<span class="regexp">/test\d?/</span>) ; <span class="comment">// null</span></div><div class="line"><span class="string">"test1"</span>.match(<span class="regexp">/test\d?/</span>); <span class="comment">//["test1"]</span></div></pre></td></tr></table></figure>
<p>从上面的结果可以看到，字符test后边跟着的数字可以重复0次或多次时，正则表达式捕获的子字符串会返回尽量多的数字，比如/test\d*/匹配 test123 ，返回的是test123，而不是test或者test12。</p>
<p>正则表达式捕获字符串时，在满足条件的情况下捕获尽可能多的字符串，这就是所谓的“贪婪模式”。</p>
<p>对应的”懒惰模式“，就是在满足条件的情况下捕获尽可能少的字符串，使用懒惰模式的方法，就是在字符重复标识后面加上一个 “?”，写法如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 数字重复3~5次，满足条件的情况下返回尽可能少的数字</span></div><div class="line"><span class="string">"test12345"</span>.match(<span class="regexp">/test\d&#123;3,5&#125;?/</span>);  <span class="comment">//["test123"]</span></div><div class="line"><span class="comment">// 数字重复1次或更多，满足条件的情况下只返回一个数字</span></div><div class="line"><span class="string">"test12345"</span>.match(<span class="regexp">/test\d+?/</span>);  <span class="comment">// ["test1"]</span></div></pre></td></tr></table></figure>
<h2 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h2><p>在正则表达式中元字符是有特殊的含义的，当我们要匹配元字符本身时，就需要用到字符转义，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/\./.test(<span class="string">"."</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h2 id="分组-amp-分支条件"><a href="#分组-amp-分支条件" class="headerlink" title="分组 &amp; 分支条件"></a>分组 &amp; 分支条件</h2><p>正则表达式可以用 “ ()  “ 来进行分组，具有分组的正则表达式除了正则表达式整体会匹配子字符串外，分组中的正则表达式片段也会匹配字符串。</p>
<p>分组按照嵌套关系和前后关系，每个分组会分配得到一个数字组号，在一些场景中可以用组号来使用分组。</p>
<p>在 replace、match、exec函数中，分组都能体现不同的功能。</p>
<p><strong>replace函数</strong>中，第二个参数里边可以用 $+数字组号来指代第几个分组的内容，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">" the best language in the world is java "</span>.replace(<span class="regexp">/(java)/</span>,<span class="string">"$1script"</span>); <span class="comment">// " the best language in the world is javascript "</span></div><div class="line"><span class="string">"/static/app1/js/index.js"</span>.replace(<span class="regexp">/(\/\w+)\.js/</span>,<span class="string">"$1-v0.0.1.js"</span>); <span class="comment">//"/static/app1/js/index-v0.0.1.js"    (\/\w+)分组匹配的就是 /index ，在第二个参数中为其添加上版本号</span></div></pre></td></tr></table></figure>
<p><strong>match函数</strong>中，当正则表达式有全局属性时，会捕获所有满足正则表达式的子字符串</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"abchellodefhellog"</span>.match(<span class="regexp">/h(ell)o/g</span>); <span class="comment">//["hello", "hello"]</span></div></pre></td></tr></table></figure>
<p>但是当正则表达式没有全局属性，且正则表达式中有分组的时候，match函数只会返回整个正则表达式匹配的第一个结果，同时会将分组匹配到的字符串也放入结果数组中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">"abchellodefhellog"</span>.match(<span class="regexp">/h(ell)o/</span>); <span class="comment">//["hello", "ell"]</span></div><div class="line"><span class="comment">// 我们可以用match函数来分解url，获取协议、host、path、查询字符串等信息</span></div><div class="line"><span class="string">"http://www.baidu.com/test?t=5"</span>.match(<span class="regexp">/^((\w+):\/\/([\w\.]+))\/([^?]+)\?(\S+)$/</span>);</div><div class="line"><span class="comment">// ["http://www.baidu.com/test?t=5", "http://www.baidu.com", "http", "www.baidu.com", "test", "t=5"]</span></div></pre></td></tr></table></figure>
<p><strong>exec函数</strong>在正则表达式中有分组的情况下，表现和match函数很像，只是无论正则表达式是否有全局属性，exec函数都只返回一个结果，并捕获分组的结果</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/h(ell)o/g.exec(<span class="string">"abchellodefhellog"</span>); <span class="comment">//["hello", "ell"]</span></div></pre></td></tr></table></figure>
<p>当正则表达式需要匹配几种类型的结果时，可以用到<strong>分支条件</strong>，例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">"asdasd hi  asdad hello asdasd"</span>.replace(<span class="regexp">/hi|hello/</span>,<span class="string">"nihao"</span>); <span class="comment">//"asdasd nihao  asdad hello asdasd"</span></div><div class="line"><span class="string">"asdasd hi  asdad hello asdasd"</span>.split(<span class="regexp">/hi|hello/</span>); <span class="comment">//["asdasd ", "  asdad ", " asdasd"]</span></div></pre></td></tr></table></figure>
<p> 注意，分支条件影响它两边的所有内容， 比如 hi|hello  匹配的是hi或者hello，而不是 hiello 或者 hhello</p>
<p>分组中的分支条件不会影响分组外的内容</p>
<p>“abc acd  bbc bcd “.match(/(a|b)bc/g); //[“abc”, “bbc”]</p>
<h2 id="后向引用"><a href="#后向引用" class="headerlink" title="后向引用"></a>后向引用</h2><p>正则表达式的分组可以在其后边的语句中通过  +数字组号来引用</p>
<p>比如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 匹配重复的单词</span></div><div class="line">/(\b[a-zA-Z]+\b)\s+\<span class="number">1</span>/.exec(<span class="string">" asd sf  hello hello asd"</span>); <span class="comment">//["hello hello", "hello"]</span></div></pre></td></tr></table></figure>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p><strong> (?:exp)</strong> , 用此方式定义的分组，正则表达式会匹配分组中的内容，但是不再给此分组分配组号，此分组在replace、match等函数中的作用也会消失，效果如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/(hello)\sworld/.exec(<span class="string">"asdadasd hello world asdasd"</span>)  <span class="comment">// ["hello world", "hello"],正常捕获结果字符串和分组字符串</span></div><div class="line">/(?:hello)\sworld/.exec(<span class="string">"asdadasd hello world asdasd"</span>)  <span class="comment">// ["hello world"]</span></div><div class="line"></div><div class="line"><span class="string">"/static/app1/js/index.js"</span>.replace(<span class="regexp">/(\/\w+)\.js/</span>,<span class="string">"$1-v0.0.1.js"</span>); <span class="comment">//"/static/app1/js/index-v0.0.1.js"</span></div><div class="line"><span class="string">"/static/app1/js/index.js"</span>.replace(<span class="regexp">/(?:\/\w+)\.js/</span>,<span class="string">"$1-v0.0.1.js"</span>); <span class="comment">//"/static/app1/js$1-v0.0.1.js"</span></div></pre></td></tr></table></figure>
<p><strong>(?=exp) </strong>这个分组用在正则表达式的后面，用来捕获exp前面的字符，分组中的内容不会被捕获，也不分配组号</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/hello\s(?=world)/.exec(<span class="string">"asdadasd hello world asdasd"</span>)  <span class="comment">// ["hello "]</span></div></pre></td></tr></table></figure>
<p><strong>(?!exp) </strong> 和前面的断言相反，用在正则表达式的后面，捕获后面不是exp的字符，同样不捕获分组的内容，也不分配组号</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/hello\s(?!world)/.exec(<span class="string">"asdadasd hello world asdasd"</span>) <span class="comment">//null</span></div></pre></td></tr></table></figure>
<h2 id="处理选项"><a href="#处理选项" class="headerlink" title="处理选项"></a>处理选项</h2><p>javascript中正则表达式支持的正则表达式有三个，g、i、m，分别代表全局匹配、忽略大小写、多行模式。三种属性可以自由组合共存。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 全局匹配  g </span></div><div class="line"><span class="string">"abchelloasdasdhelloasd"</span>.match(<span class="regexp">/hello/</span>);  <span class="comment">//["hello"]</span></div><div class="line"><span class="string">"abchelloasdasdhelloasd"</span>.match(<span class="regexp">/hello/g</span>);  <span class="comment">//["hello","hello"]</span></div><div class="line"></div><div class="line"><span class="comment">//忽略大小写 i</span></div><div class="line"><span class="string">"abchelloasdasdHelloasd"</span>.match(<span class="regexp">/hello/g</span>); <span class="comment">//["hello"]</span></div><div class="line"><span class="string">"abchelloasdasdHelloasd"</span>.match(<span class="regexp">/hello/gi</span>); <span class="comment">//["hello","Hello"]</span></div></pre></td></tr></table></figure>
<p>在默认的模式下，元字符 ^ 和 $ 分别匹配字符串的开头和结尾处，模式 m 改变了这俩元字符的定义，让他们匹配一行的开头和结尾</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">"aadasd\nbasdc"</span>.match(<span class="regexp">/^[a-z]+$/g</span>);  <span class="comment">//null  字符串^和$之间有换行符，匹配不上 [a-z]+ ,故返回null</span></div><div class="line"><span class="string">"aadasd\nbasdc"</span>.match(<span class="regexp">/^[a-z]+$/gm</span>);  <span class="comment">// ["aadasd", "basdc"] ，改变^$的含义，让其匹配一行的开头和末尾，可以得到两行的结果</span></div></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文章转自我的博客园博客 <a href="http://www.cnblogs.com/tzyy/p/4927476.html" target="_blank" rel="external">原文地址</a>     </p>
<p>正则表达式用来处理字符串特别好用，在J]]>
    </summary>
    
      <category term="javascript" scheme="http://www.zoucz.com/blog/tags/javascript/"/>
    
      <category term="正则表达式" scheme="http://www.zoucz.com/blog/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="前端开发" scheme="http://www.zoucz.com/blog/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[浏览器中用JavaScript获取剪切板中的文件]]></title>
    <link href="http://www.zoucz.com/blog/2016/01/29/get-file-from-clipboard/"/>
    <id>http://www.zoucz.com/blog/2016/01/29/get-file-from-clipboard/</id>
    <published>2016-01-29T03:17:04.000Z</published>
    <updated>2016-12-21T16:42:00.000Z</updated>
    <content type="html"><![CDATA[<p>在网页上编辑内容时，有时候需要插入图片，一般的做法是：  </p>
<ol>
<li>从网络上下载图片至本地 or  截图保存至本地</li>
<li>在编辑器中点击图片上传按钮，选择本地文件，等待上传完成</li>
<li>将上传好的图片链接插入编辑器中  </li>
</ol>
<p>这样做太麻烦了，我比较喜欢的操作是开着QQ或者其他的一些截图工具，截图-粘贴  。<br>为了这样做我们需要在浏览器中获取剪切板中的文件。<br>chrome浏览器支持onPaste事件，事件对象中可以获取剪切板中的文件内容，代码如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">paste</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> items = (event.clipboardData || event.originalEvent.clipboardData).items;</div><div class="line">    <span class="keyword">var</span> dfd=Q.defer();</div><div class="line">    <span class="keyword">if</span>(items.length&gt;<span class="number">0</span> &amp;&amp; items[<span class="number">0</span>].kind===<span class="string">"file"</span>)&#123;</div><div class="line">        <span class="keyword">var</span> blob = items[<span class="number">0</span>].getAsFile();</div><div class="line">        <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</div><div class="line">        <span class="keyword">var</span> filename=<span class="keyword">new</span> <span class="built_in">Date</span>().getTime()+<span class="string">".png"</span>;</div><div class="line">        reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">            <span class="keyword">var</span> base64=e.target.result;</div><div class="line">            base64=base64.replace(<span class="regexp">/^data:image\/(png|jpg);base64,/</span>, <span class="string">""</span>);</div><div class="line">            <span class="keyword">var</span> path=writeImg(filename,base64);</div><div class="line">            dfd.resolve(path);</div><div class="line">        &#125;;</div><div class="line">        reader.readAsDataURL(blob);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        dfd.resolve();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dfd.promise;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中Q是一个promise库，writeImg是一个使用node写入本地文件系统(nw.js下运行)，见<a href="https://github.com/zouchengzhuo/blog/tree/master/nw_blog_creator" target="_blank" rel="external">我的blog编辑器</a><br>FileReader可以把blob对象读取为dataurl（实际上就是用base64表示的uri），ArrayBuffer等格式的数据：<br><img src="http://zoucz.com/blogimgs/2016-01-29/1454036632733.png" alt="reader">   </p>
<p>当这种场景发生在纯浏览器环境时，writeImg方法也可以选择不保存到本地，而是通过http上传到一个文件服务器，此时可以直接用blob对象上传而不用读取。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在网页上编辑内容时，有时候需要插入图片，一般的做法是：  </p>
<ol>
<li>从网络上下载图片至本地 or  截图保存至本地</li>
<li>在编辑器中点击图片上传按钮，选择本地文件，等待上传完成</li>
<li>将上传好的图片链接插入编辑器中  </li>
<]]>
    </summary>
    
      <category term="前端开发" scheme="http://www.zoucz.com/blog/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="浏览器" scheme="http://www.zoucz.com/blog/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="前端开发" scheme="http://www.zoucz.com/blog/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[markdown语法]]></title>
    <link href="http://www.zoucz.com/blog/2016/01/26/markdown/"/>
    <id>http://www.zoucz.com/blog/2016/01/26/markdown/</id>
    <published>2016-01-26T10:00:31.000Z</published>
    <updated>2016-12-21T16:42:00.000Z</updated>
    <content type="html"><![CDATA[<p>Markdown 是一种轻量级标记语言，能将文本换成有效的XHTML(或者HTML)文档，它的目标是实现易读易写，成为一种适用于网络的书写语言。</p>
<p>Markdown 语法简洁明了，易于掌握，所以用它来写作是件既效率又舒服的事情。我们所熟知的和一些大型CMS，如Joomla!、Drupal等都能很好的支持Markdown。我是因为写GitHub项目库中的Readme才开始接触Markdown。</p>
<p>Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想不是要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。</p>
<p>Headers 标题：</p>
<h1 id="H1"><a href="#H1" class="headerlink" title="H1"></a>H1</h1><h2 id="H2"><a href="#H2" class="headerlink" title="H2"></a>H2</h2><h3 id="H3"><a href="#H3" class="headerlink" title="H3"></a>H3</h3><h4 id="H4"><a href="#H4" class="headerlink" title="H4"></a>H4</h4><h5 id="H5"><a href="#H5" class="headerlink" title="H5"></a>H5</h5><h6 id="H6"><a href="#H6" class="headerlink" title="H6"></a>H6</h6><p>另外，H1和H2还能用以下方式显示：</p>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p>Emphasis 文本强调：</p>
<p><em>斜体</em> or <em>强调</em><br><strong>加粗</strong> or <strong>加粗</strong><br><strong><em>粗斜体</em></strong> or <strong>_粗斜体</strong></p>
<p>但是，如果你的 <em> 和 _ 两边都有空白的话，它们就只会被当成普通的符号：这是一段</em> 文本强调 <em>的说明示例。<br>如果要在文字前后直接插入普通的星号或底线，你可以用反斜线（转义符）：\</em>this text is surrounded by literal asterisks*<br>Lists 列表：</p>
<p>Unordered 无序列表：</p>
<ul>
<li>无序列表</li>
<li>子项</li>
<li>子项</li>
</ul>
<ul>
<li>无序列表</li>
<li>子项</li>
<li>子项</li>
</ul>
<ul>
<li>无序列表</li>
<li>子项</li>
<li>子项</li>
</ul>
<p>Ordered 有序列表：</p>
<ol>
<li>第一行</li>
<li>第二行</li>
<li><p>第三行</p>
</li>
<li><p>第一行</p>
</li>
</ol>
<ul>
<li>第二行</li>
<li>第三行</li>
</ul>
<p>组合：</p>
<ul>
<li><p>产品介绍（子项无项目符号）<br>  此时子项，要以一个制表符或者4个空格缩进</p>
</li>
<li><p>产品特点</p>
<ol>
<li>特点1</li>
</ol>
<ul>
<li>特点2</li>
<li>特点3</li>
</ul>
</li>
<li>产品功能<ol>
<li>功能1</li>
</ol>
<ul>
<li>功能2</li>
<li>功能3</li>
</ul>
</li>
</ul>
<p>可有时我们会出现这样的情况，首行内容是以日期或数字开头：2013. 公司年度目标。<br>为了避免也被转化成有序列表，我们可以在”.”前加上反斜杠（转义符）：2013. 公司年度目标。<br>Links 连接（title为可选项）：</p>
<p>Inline-style 内嵌方式：<br><a href="https://www.google.com" title="title text" target="_blank" rel="external">link text</a></p>
<p>Reference-style 引用方式：<br><a href="https://www.mozilla.org" title="title text" target="_blank" rel="external">link text</a></p>
<p>Relative reference to a repository file 引用存储文件：<br><a href="../path/file/readme.text" title="title text">link text</a></p>
<p>还能这样使用：<br><a href="http://www.reddit.com" target="_blank" rel="external">link text</a></p>
<p>Email 邮件：<br><a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#x65;&#x78;&#x61;&#x6d;&#x70;&#108;&#x65;&#64;&#x65;&#120;&#x61;&#109;&#x70;&#108;&#101;&#x2e;&#x63;&#x6f;&#109;">&#x65;&#x78;&#x61;&#x6d;&#x70;&#108;&#x65;&#64;&#x65;&#120;&#x61;&#109;&#x70;&#108;&#101;&#x2e;&#x63;&#x6f;&#109;</a><br>Images 图片：</p>
<p>Inline-style 内嵌方式：<br><img src="https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png" alt="alt text" title="title text"></p>
<p>Reference-style 引用方式：<br><img src="https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png" alt="alt text" title="title text"></p>
<p>Code and Syntax Highlighting 代码和语法高亮：</p>
<p>标记一小段行内代码：<br>本文是一篇介绍<code>Markdown</code>的语法的文章</p>
<p>如果高亮的内容包含<code>号，可以这样写：
`` </code>包裹起来` ``</p>
<p>语法高亮：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Syntax Highlighting<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span>&#123;<span class="attribute">font-size</span>:<span class="number">12px</span>&#125;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="string">"JavaScript syntax highlighting"</span>;</div><div class="line">alert(s);</div></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">  <span class="keyword">echo</span> <span class="string">"hello, world!"</span>;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s = <span class="string">"Python syntax highlighting"</span></div><div class="line"><span class="keyword">print</span> s</div></pre></td></tr></table></figure>
<p>Block Code 代码分组(代码区块)：</p>
<p>在该行开头缩进4个空格或一个制表符(tab)</p>
<p><strong>Blockquotes 引用：</strong></p>
<blockquote>
<p>Email-style angle brackets<br>are used for blockquotes.</p>
<blockquote>
<p>And, they can be nested.</p>
<h4 id="Headers-in-blockquotes"><a href="#Headers-in-blockquotes" class="headerlink" title="Headers in blockquotes"></a>Headers in blockquotes</h4><ul>
<li>You can quote a list.</li>
<li>Etc.<br>Hard Line Breaks 换行：</li>
</ul>
</blockquote>
</blockquote>
<p>在一行的结尾处加上2个或2个以上的空格，也可以使用<br>标签<br>第一行文字，<br>第二行文字<br>Horizontal Rules 水平分割线：</p>
<hr>
<hr>
<hr>
<p>Escape character 转义符(反斜杠)：</p>
<p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果，你可以在星号的前面加上反斜杠：<br>*literal asterisks*<br>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：<br>\反斜杠  `反引号  *星号  _下划线  {}花括号  []方括号  ()括弧  #井字号  +加号  -减号  .英文句 !感叹号<br>Additional 补充：</p>
<p>Markdown也支持传统的HTML标签。<br>比如一个链接，你不太喜欢Markdown的写法，也可以直接写成<a href="http://www.baidu.com" target="_blank" rel="external">百度</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Markdown 是一种轻量级标记语言，能将文本换成有效的XHTML(或者HTML)文档，它的目标是实现易读易写，成为一种适用于网络的书写语言。</p>
<p>Markdown 语法简洁明了，易于掌握，所以用它来写作是件既效率又舒服的事情。我们所熟知的和一些大型CMS，如J]]>
    </summary>
    
      <category term="markdown" scheme="http://www.zoucz.com/blog/tags/markdown/"/>
    
      <category term="前端杂烩" scheme="http://www.zoucz.com/blog/categories/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/"/>
    
  </entry>
  
</feed>
